[{"/Users/will/wox/src/index.tsx":"1","/Users/will/wox/src/App.tsx":"2","/Users/will/wox/src/AlwaysLongShadaws.ts":"3","/Users/will/wox/src/UserInput.tsx":"4","/Users/will/wox/src/Light.tsx":"5","/Users/will/wox/src/HighlightGrid.tsx":"6","/Users/will/wox/src/PlaceStructure.tsx":"7","/Users/will/wox/src/Structures.tsx":"8","/Users/will/wox/src/Grid/Grids.tsx":"9","/Users/will/wox/src/Trees/Trees.tsx":"10","/Users/will/wox/src/Waterfalls/Waterfalls.tsx":"11","/Users/will/wox/src/Water/Water.tsx":"12","/Users/will/wox/src/features/chunks/Mesher.tsx":"13","/Users/will/wox/src/features/ground/store.ts":"14","/Users/will/wox/src/features/camera/components/CameraController.tsx":"15","/Users/will/wox/src/features/ground/components/Ground/Ground.tsx":"16","/Users/will/wox/src/stores/light.ts":"17","/Users/will/wox/src/features/camera/store.ts":"18","/Users/will/wox/src/stores/input.ts":"19","/Users/will/wox/src/raycast.ts":"20","/Users/will/wox/src/Grid/constants.ts":"21","/Users/will/wox/src/Layers.ts":"22","/Users/will/wox/src/features/chunks/store.ts":"23","/Users/will/wox/src/stores/grid.ts":"24","/Users/will/wox/src/stores/structure.ts":"25","/Users/will/wox/src/Structure.tsx":"26","/Users/will/wox/src/constants.ts":"27","/Users/will/wox/src/stores/waterfall.ts":"28","/Users/will/wox/src/stores/water.ts":"29","/Users/will/wox/src/utils/math.ts":"30","/Users/will/wox/src/utils/Curve.ts":"31","/Users/will/wox/src/Grid/GridChunk.tsx":"32","/Users/will/wox/src/Trees/TreeChunk.tsx":"33","/Users/will/wox/src/Water/WaterChunk.tsx":"34","/Users/will/wox/src/Waterfalls/WaterfallChunk.tsx":"35","/Users/will/wox/src/Noise.tsx":"36","/Users/will/wox/src/features/ground/components/Ground/GroundChunk.tsx":"37","/Users/will/wox/src/features/ground/components/Ground/wait.tsx":"38","/Users/will/wox/src/features/chunks/components/Chunks.tsx":"39","/Users/will/wox/src/features/chunks/getFaceInfo.ts":"40","/Users/will/wox/src/features/chunks/ChunksData.ts":"41","/Users/will/wox/src/features/chunks/meshChunk.ts":"42","/Users/will/wox/src/Waterfalls/traceWaterfall.ts":"43","/Users/will/wox/src/Brushes/placeStructure.tsx":"44","/Users/will/wox/src/stores/tree.ts":"45","/Users/will/wox/src/Trees/Tree.tsx":"46","/Users/will/wox/src/Waterfalls/Waterfall.tsx":"47","/Users/will/wox/src/features/chunks/components/Chunk.tsx":"48","/Users/will/wox/src/features/chunks/ChunkData.ts":"49","/Users/will/wox/src/utils/QuadMap.ts":"50","/Users/will/wox/src/Trees/placeTree.ts":"51","/Users/will/wox/src/features/chunks/voxelShader.ts":"52","/Users/will/wox/src/utils/sdf.ts":"53"},{"size":146,"mtime":1607134970915,"results":"54","hashOfConfig":"55"},{"size":2021,"mtime":1607155928053,"results":"56","hashOfConfig":"55"},{"size":911,"mtime":1607134970893,"results":"57","hashOfConfig":"55"},{"size":1623,"mtime":1607134970910,"results":"58","hashOfConfig":"55"},{"size":1381,"mtime":1607134970905,"results":"59","hashOfConfig":"55"},{"size":3086,"mtime":1607135374444,"results":"60","hashOfConfig":"55"},{"size":741,"mtime":1607134970906,"results":"61","hashOfConfig":"55"},{"size":408,"mtime":1607134970907,"results":"62","hashOfConfig":"55"},{"size":930,"mtime":1607155838548,"results":"63","hashOfConfig":"55"},{"size":509,"mtime":1607155824130,"results":"64","hashOfConfig":"55"},{"size":1030,"mtime":1607155819000,"results":"65","hashOfConfig":"55"},{"size":451,"mtime":1607155781756,"results":"66","hashOfConfig":"55"},{"size":1473,"mtime":1607153047582,"results":"67","hashOfConfig":"55"},{"size":3829,"mtime":1607155879779,"results":"68","hashOfConfig":"55"},{"size":1580,"mtime":1607155864282,"results":"69","hashOfConfig":"55"},{"size":2522,"mtime":1607153998263,"results":"70","hashOfConfig":"55"},{"size":436,"mtime":1607134970922,"results":"71","hashOfConfig":"55"},{"size":946,"mtime":1607155843405,"results":"72","hashOfConfig":"55"},{"size":479,"mtime":1607134970921,"results":"73","hashOfConfig":"55"},{"size":1449,"mtime":1607135474454,"results":"74","hashOfConfig":"55"},{"size":27,"mtime":1599466426773,"results":"75","hashOfConfig":"55"},{"size":97,"mtime":1607134970905,"results":"76","hashOfConfig":"55"},{"size":2047,"mtime":1607135484844,"results":"77","hashOfConfig":"55"},{"size":3283,"mtime":1607155827489,"results":"78","hashOfConfig":"55"},{"size":552,"mtime":1607134970922,"results":"79","hashOfConfig":"55"},{"size":553,"mtime":1607135374713,"results":"80","hashOfConfig":"55"},{"size":28,"mtime":1607134970913,"results":"81","hashOfConfig":"55"},{"size":3448,"mtime":1607155832299,"results":"82","hashOfConfig":"55"},{"size":1475,"mtime":1607135377593,"results":"83","hashOfConfig":"55"},{"size":1448,"mtime":1607134970926,"results":"84","hashOfConfig":"55"},{"size":922,"mtime":1607134970925,"results":"85","hashOfConfig":"55"},{"size":1060,"mtime":1607155835705,"results":"86","hashOfConfig":"55"},{"size":854,"mtime":1607134970908,"results":"87","hashOfConfig":"55"},{"size":525,"mtime":1607134970911,"results":"88","hashOfConfig":"55"},{"size":1141,"mtime":1607155814562,"results":"89","hashOfConfig":"55"},{"size":1571,"mtime":1607134970906,"results":"90","hashOfConfig":"55"},{"size":467,"mtime":1607154000895,"results":"91","hashOfConfig":"55"},{"size":131,"mtime":1599963160080,"results":"92","hashOfConfig":"55"},{"size":575,"mtime":1607153046682,"results":"93","hashOfConfig":"55"},{"size":251,"mtime":1607135490110,"results":"94","hashOfConfig":"55"},{"size":2709,"mtime":1607153415184,"results":"95","hashOfConfig":"55"},{"size":5613,"mtime":1607135502313,"results":"96","hashOfConfig":"55"},{"size":3464,"mtime":1607135453785,"results":"97","hashOfConfig":"55"},{"size":2493,"mtime":1607135456330,"results":"98","hashOfConfig":"55"},{"size":2879,"mtime":1607155829932,"results":"99","hashOfConfig":"55"},{"size":525,"mtime":1607135372763,"results":"100","hashOfConfig":"55"},{"size":1151,"mtime":1607135455278,"results":"101","hashOfConfig":"55"},{"size":4908,"mtime":1607153077870,"results":"102","hashOfConfig":"55"},{"size":3107,"mtime":1607135489033,"results":"103","hashOfConfig":"55"},{"size":3573,"mtime":1607134970926,"results":"104","hashOfConfig":"55"},{"size":2709,"mtime":1607135455611,"results":"105","hashOfConfig":"55"},{"size":1921,"mtime":1607135510361,"results":"106","hashOfConfig":"55"},{"size":1192,"mtime":1607134970926,"results":"107","hashOfConfig":"55"},{"filePath":"108","messages":"109","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"110"},"1ys15qs",{"filePath":"111","messages":"112","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"113","usedDeprecatedRules":"110"},{"filePath":"114","messages":"115","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"116","usedDeprecatedRules":"110"},{"filePath":"117","messages":"118","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"119","usedDeprecatedRules":"110"},{"filePath":"120","messages":"121","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"122","usedDeprecatedRules":"110"},{"filePath":"123","messages":"124","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"125","usedDeprecatedRules":"110"},{"filePath":"126","messages":"127","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"128","usedDeprecatedRules":"110"},{"filePath":"129","messages":"130","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"131","usedDeprecatedRules":"110"},{"filePath":"132","messages":"133","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"134","usedDeprecatedRules":"110"},{"filePath":"135","messages":"136","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"137","usedDeprecatedRules":"110"},{"filePath":"138","messages":"139","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"140","usedDeprecatedRules":"110"},{"filePath":"141","messages":"142","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"143","usedDeprecatedRules":"110"},{"filePath":"144","messages":"145","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"146","usedDeprecatedRules":"110"},{"filePath":"147","messages":"148","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"149","usedDeprecatedRules":"110"},{"filePath":"150","messages":"151","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"152","usedDeprecatedRules":"110"},{"filePath":"153","messages":"154","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"155","usedDeprecatedRules":"110"},{"filePath":"156","messages":"157","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"110"},{"filePath":"158","messages":"159","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"110"},{"filePath":"160","messages":"161","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"110"},{"filePath":"162","messages":"163","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"164","usedDeprecatedRules":"110"},{"filePath":"165","messages":"166","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"110"},{"filePath":"167","messages":"168","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"110"},{"filePath":"169","messages":"170","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"171","usedDeprecatedRules":"110"},{"filePath":"172","messages":"173","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"174","usedDeprecatedRules":"110"},{"filePath":"175","messages":"176","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"110"},{"filePath":"177","messages":"178","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"179","usedDeprecatedRules":"110"},{"filePath":"180","messages":"181","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"110"},{"filePath":"182","messages":"183","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"184","usedDeprecatedRules":"110"},{"filePath":"185","messages":"186","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"187","usedDeprecatedRules":"110"},{"filePath":"188","messages":"189","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"190","usedDeprecatedRules":"110"},{"filePath":"191","messages":"192","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"193","usedDeprecatedRules":"110"},{"filePath":"194","messages":"195","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"196","usedDeprecatedRules":"110"},{"filePath":"197","messages":"198","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"199","usedDeprecatedRules":"110"},{"filePath":"200","messages":"201","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"202","usedDeprecatedRules":"110"},{"filePath":"203","messages":"204","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"205","usedDeprecatedRules":"110"},{"filePath":"206","messages":"207","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"208","usedDeprecatedRules":"110"},{"filePath":"209","messages":"210","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"211","usedDeprecatedRules":"110"},{"filePath":"212","messages":"213","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"214","usedDeprecatedRules":"110"},{"filePath":"215","messages":"216","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"217","usedDeprecatedRules":"110"},{"filePath":"218","messages":"219","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"110"},{"filePath":"220","messages":"221","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"222","usedDeprecatedRules":"110"},{"filePath":"223","messages":"224","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"110"},{"filePath":"225","messages":"226","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"227","usedDeprecatedRules":"110"},{"filePath":"228","messages":"229","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"230","usedDeprecatedRules":"110"},{"filePath":"231","messages":"232","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"233","usedDeprecatedRules":"110"},{"filePath":"234","messages":"235","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"236","usedDeprecatedRules":"110"},{"filePath":"237","messages":"238","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"239","usedDeprecatedRules":"110"},{"filePath":"240","messages":"241","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"242","usedDeprecatedRules":"110"},{"filePath":"243","messages":"244","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"245","usedDeprecatedRules":"110"},{"filePath":"246","messages":"247","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"248","usedDeprecatedRules":"110"},{"filePath":"249","messages":"250","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"251","usedDeprecatedRules":"110"},{"filePath":"252","messages":"253","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"110"},{"filePath":"254","messages":"255","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"256","usedDeprecatedRules":"257"},"/Users/will/wox/src/index.tsx",[],[],"/Users/will/wox/src/App.tsx",["258","259","260","261","262","263","264","265","266","267","268","269"],"import React, { useEffect } from \"react\";\nimport { Canvas } from \"react-three-fiber\";\nimport UserInput from \"./UserInput\";\nimport CameraController from \"./features/camera/components/CameraController\";\nimport { Stats } from \"drei\";\nimport { Vector3, VSMShadowMap } from \"three\";\nimport Ground from \"./features/ground/components/Ground/Ground\";\nimport AlwaysLongShadaws from \"./AlwaysLongShadaws\";\nimport Light from \"./Light\";\nimport HighlightHover from \"./HighlightHover\";\nimport { chunkSize } from \"./constants\";\nimport PlaceObject from \"./Brushes/PlaceObject\";\nimport ChunksData from \"./features/chunks/ChunksData\";\nimport { VoxelInfo } from \"./features/chunks/VoxelInfo\";\nimport Layers from \"./Layers\";\nimport placeRock from \"./Brushes/placeRock\";\nimport placeTree from \"./Brushes/placeTree\";\nimport Structure from \"./Structure\";\nimport Grids from \"./Grid/Grids\";\nimport HighlightGrid from \"./HighlightGrid\";\nimport PlaceStructure from \"./PlaceStructure\";\nimport Structures from \"./Structures\";\nimport Mesher from \"./features/chunks/Mesher\";\nimport Waterfalls from \"./Waterfalls/Waterfalls\";\nimport Trees from \"./Trees/Trees\";\nimport Water from \"./Water/Water\";\nimport { useGroundStore } from \"./features/ground/store\";\n\nimport \"./app.css\";\n\nexport default () => {\n  const size = useGroundStore((state) => state.size);\n\n  return (\n    <>\n      <Canvas\n        camera={{ fov: 30 }}\n        shadowMap={{\n          enabled: true,\n          type: VSMShadowMap,\n        }}\n        onCreated={(props) => {\n          props.gl.setClearColor(0x000000);\n        }}\n      >\n        <Light />\n        <CameraController />\n        <Ground size={size} seed={1337} />\n        <AlwaysLongShadaws />\n        {/* <HighlightHover /> */}\n        <HighlightGrid />\n        <PlaceStructure />\n        {/* <Brush /> */}\n        {/* <PlaceWaterfall /> */}\n        <Grids />\n        <Structures />\n        <Mesher />\n        <Waterfalls />\n        <Trees />\n        <Water />\n      </Canvas>\n      <UserInput />\n      <Stats />\n    </>\n  );\n};\n","/Users/will/wox/src/AlwaysLongShadaws.ts",["270","271"],"import { useFrame, useThree } from \"react-three-fiber\";\nimport { Vector3 } from \"three\";\nimport _ from \"lodash\";\nimport { useLightStore } from \"./stores/light\";\n\nexport default () => {\n  const { camera } = useThree();\n  const lightDirs = [\n    new Vector3(-1, -1, -1),\n    new Vector3(1, -1, -1),\n    new Vector3(1, -1, 1),\n    new Vector3(-1, -1, 1),\n  ].map((x) => x.normalize());\n\n  const setLightDir = useLightStore((state) => state.setLightDir);\n  const lightDir = useLightStore((state) => state.lightDir);\n\n  useFrame(() => {\n    const forward = new Vector3(0, 0, 1)\n      .applyEuler(camera.rotation)\n      .projectOnPlane(new Vector3(0, 1, 0))\n      .normalize();\n\n    const up = new Vector3(0, 1, 0);\n    const right = forward.cross(up);\n\n    const d = _.maxBy(lightDirs, (d) => {\n      return right.dot(d);\n    })!;\n\n    if (!d.equals(lightDir)) {\n      setLightDir(d);\n    }\n  });\n\n  return null;\n};\n","/Users/will/wox/src/UserInput.tsx",["272"],"import { useEffect } from \"react\";\nimport keycode from \"keycode\";\nimport { useInputStore } from \"./stores/input\";\nimport { Vector2 } from \"three\";\nimport { useCameraStore } from \"./features/camera/store\";\n\nexport default () => {\n  const zoomRate = 1.1;\n\n  const targetRotation = useCameraStore((state) => state.targetRotation);\n  const distance = useCameraStore((state) => state.distance);\n  const setMouse = useInputStore((state) => state.setMouse);\n  const setTargetRotation = useCameraStore((state) => state.setTargetRotation);\n  const setDistance = useCameraStore((state) => state.setDistance);\n\n  const handleKeyUp = (e: KeyboardEvent) => {\n    const key = keycode(e);\n    if (key === \"q\") {\n      const next = targetRotation;\n      next[1] -= Math.PI / 2;\n      setTargetRotation(next);\n    } else if (key === \"e\") {\n      const next = targetRotation;\n      next[1] += Math.PI / 2;\n      setTargetRotation(next);\n    }\n\n    if (key === \"=\") {\n      setDistance(distance / zoomRate);\n    } else if (key === \"-\") {\n      setDistance(distance * zoomRate);\n    }\n  };\n\n  const handleMouseMove = (e: MouseEvent) => {\n    const x = (e.clientX / window.innerWidth) * 2 - 1;\n    const y = -(e.clientY / window.innerHeight) * 2 + 1;\n    setMouse(new Vector2(x, y));\n  };\n\n  useEffect(() => {\n    window.addEventListener(\"keyup\", handleKeyUp);\n    return () => {\n      window.removeEventListener(\"keyup\", handleKeyUp);\n    };\n  });\n\n  useEffect(() => {\n    window.addEventListener(\"mousemove\", handleMouseMove);\n    return () => {\n      window.removeEventListener(\"mousemove\", handleMouseMove);\n    };\n  });\n\n  return null;\n};\n","/Users/will/wox/src/Light.tsx",["273"],"import { DirectionalLight, Vector3, Vector2, CameraHelper } from \"three\";\nimport React, { useEffect } from \"react\";\nimport { useCameraStore } from \"./features/camera/store\";\nimport { useLightStore } from \"./stores/light\";\n\nexport default () => {\n  const lightDir = useLightStore((state) => state.lightDir);\n  const target = useCameraStore((state) => state.target);\n  const showHelper = false;\n  const distance = 150;\n\n  useEffect(() => {\n    light.position.copy(calcPosition());\n    light.target.position.set(...target);\n  }, [lightDir, target]);\n\n  const calcPosition = () => {\n    return lightDir\n      .clone()\n      .multiply(new Vector3(-1, -1, -1))\n      .multiplyScalar(distance)\n      .add(new Vector3(...target));\n  };\n\n  const light = new DirectionalLight();\n  light.position.copy(calcPosition());\n  light.target.position.set(...target);\n  light.castShadow = true;\n\n  const camera = light.shadow.camera;\n  camera.left = -100;\n  camera.right = 100;\n  camera.top = 100;\n  camera.bottom = -100;\n  camera.near = 0.1;\n  camera.far = 10000;\n\n  light.shadow.mapSize = new Vector2(1024, 1024);\n  light.shadow.normalBias = 0.5;\n  light.shadow.bias = 0;\n\n  const helper = new CameraHelper(light.shadow.camera);\n\n  return (\n    <>\n      <primitive object={light} />\n      <primitive object={light.target} />\n      {showHelper ? <primitive object={helper} /> : null}\n    </>\n  );\n};\n","/Users/will/wox/src/HighlightGrid.tsx",["274"],"import { useInputStore } from \"./stores/input\";\nimport { useEffect, useState } from \"react\";\nimport raycast from \"./raycast\";\nimport { useThree } from \"react-three-fiber\";\nimport Layers from \"./Layers\";\nimport { Vector2, Vector3, Geometry, Face3 } from \"three\";\nimport { gridSize } from \"./Grid/constants\";\nimport React from \"react\";\nimport { useGridStore } from \"./stores/grid\";\nimport { useChunkStore } from \"./features/chunks/store\";\n\nconst twoByTwo = {\n  coords: [\n    new Vector2(0, 0),\n    new Vector2(1, 0),\n    new Vector2(1, 1),\n    new Vector2(0, 1),\n  ],\n  center: new Vector2(0.5, 0.5),\n};\n\nexport default function HighlightGrid() {\n  const mouse = useInputStore((state) => state.mouse);\n  const chunks = useChunkStore((state) => state.chunks);\n  const grids = useGridStore((state) => state.grids);\n  const gridIds = useGridStore((state) => state.gridIds);\n  const setGridIds = useGridStore((state) => state.setGridIds);\n  const [geometry, setGeometry] = useState(new Geometry());\n\n  const { camera, scene } = useThree();\n\n  useEffect(() => {\n    const result = raycast(mouse, camera, scene, chunks, [Layers.ground]);\n    if (result == null) {\n      return;\n    }\n\n    const v = new Vector2(result.coord[0], result.coord[2]);\n    const vs = twoByTwo.coords.map((x) => {\n      return x.clone().sub(twoByTwo.center).multiplyScalar(gridSize).add(v);\n    });\n    const gos = vs.map((x) => getGrid(x));\n\n    const gridIds = gos\n      .filter((x) => {\n        const id = x.toArray().join(\",\");\n        return grids[id] != null;\n      })\n      // Sort by x then z\n      .sort((a, b) => {\n        const xd = a.x - b.x;\n        if (xd != 0) {\n          return xd;\n        }\n        return a.y - b.y;\n      })\n      .map((x) => x.toArray().join(\",\"));\n\n    setGridIds(gridIds);\n  }, [mouse]);\n\n  useEffect(() => {\n    if (gridIds?.length === 0) {\n      return;\n    }\n\n    const geometry = new Geometry();\n    const vertices: Vector3[] = [];\n    const faces: Face3[] = [];\n\n    for (const gridId of gridIds) {\n      const grid = grids[gridId];\n      if (grid == null) {\n        continue;\n      }\n      for (const coord of grid.coords) {\n        addPlane(vertices, faces, coord, new Vector3(0, 0.1, 0));\n      }\n    }\n\n    geometry.vertices = vertices;\n    geometry.faces = faces;\n\n    setGeometry(geometry);\n  }, [gridIds]);\n\n  return <mesh geometry={geometry} />;\n}\n\nfunction addPlane(\n  vertices: Vector3[],\n  faces: Face3[],\n  coord: Vector3,\n  offset: Vector3\n) {\n  const vs = [\n    new Vector3(0, 1, 0),\n    new Vector3(1, 1, 0),\n    new Vector3(1, 1, 1),\n    new Vector3(0, 1, 1),\n  ];\n\n  vs.forEach((v) => {\n    v.add(coord).add(offset);\n  });\n\n  const index = vertices.length;\n  vertices.push(...vs);\n  faces.push(new Face3(index, index + 1, index + 2));\n  faces.push(new Face3(index + 2, index + 3, index));\n  faces.push(new Face3(index + 2, index + 1, index));\n  faces.push(new Face3(index, index + 3, index + 2));\n}\n\nfunction getGrid(coord: Vector2) {\n  return new Vector2(\n    Math.floor(coord.x / gridSize) * gridSize,\n    Math.floor(coord.y / gridSize) * gridSize\n  );\n}\n","/Users/will/wox/src/PlaceStructure.tsx",["275"],"import { useEffect } from \"react\";\nimport { useStructureStore } from \"./stores/structure\";\nimport { useGridStore } from \"./stores/grid\";\n\nexport default function PlaceStructure() {\n  const gridIds = useGridStore((state) => state.gridIds);\n  const addStructure = useStructureStore((state) => state.addStructure);\n\n  const handleMouseDown = (e: MouseEvent) => {\n    console.log(`add structure ${gridIds}`);\n    if (e.button !== 0) {\n      return;\n    }\n\n    if (gridIds.length != 4) {\n      return;\n    }\n\n    addStructure(gridIds);\n  };\n\n  useEffect(() => {\n    window.addEventListener(\"mousedown\", handleMouseDown);\n    return () => {\n      window.removeEventListener(\"mousedown\", handleMouseDown);\n    };\n  }, [gridIds]);\n\n  return null;\n}\n","/Users/will/wox/src/Structures.tsx",["276"],"import React from \"react\";\nimport _ from \"lodash\";\nimport Structure from \"./Structure\";\nimport { useStructureStore } from \"./stores/structure\";\n\nexport default function Structures() {\n  const structures = useStructureStore((state) => state.structures);\n\n  return (\n    <>\n      {_.map(structures, (structure) => (\n        <Structure key={structure.id} gridIds={structure.gridIds} />\n      ))}\n    </>\n  );\n}\n","/Users/will/wox/src/Grid/Grids.tsx",["277"],"import _ from \"lodash\";\nimport { Vector2 } from \"three\";\nimport { useEffect } from \"react\";\nimport React from \"react\";\nimport { chunkSize } from \"../constants\";\nimport GridChunk from \"./GridChunk\";\nimport { useGridStore } from \"../stores/grid\";\nimport { useGroundStore } from \"features/ground/store\";\n\nexport default function Grids() {\n  const size = useGroundStore((state) => state.size);\n  const gridColumns = useGridStore((state) => state.gridColumns);\n  const addGridColumns = useGridStore((state) => state.addGridColumns);\n\n  useEffect(() => {\n    const columns = [];\n    for (let i = 0; i < size.x; i++) {\n      for (let k = 0; k < size.z; k++) {\n        columns.push(new Vector2(i, k).multiplyScalar(chunkSize));\n      }\n    }\n    addGridColumns(columns);\n  }, [size]);\n\n  return (\n    <>\n      {_(gridColumns)\n        .map((column) => <GridChunk key={column.id} origin={column.origin} />)\n        .value()}\n    </>\n  );\n}\n","/Users/will/wox/src/Trees/Trees.tsx",["278"],"import React from \"react\";\nimport _ from \"lodash\";\nimport { TreeChunk } from \"./TreeChunk\";\nimport { useGroundStore } from \"features/ground/store\";\n\nexport default function Trees() {\n  const grounds = useGroundStore((state) => state.grounds);\n\n  return (\n    <>\n      {_.map(grounds, (ground) => {\n        return (\n          <TreeChunk\n            key={ground.origin.toArray().join(\",\")}\n            origin={ground.origin}\n            version={ground.version}\n          />\n        );\n      })}\n    </>\n  );\n}\n","/Users/will/wox/src/Waterfalls/Waterfalls.tsx",["279"],"import React, { useEffect } from \"react\";\nimport _ from \"lodash\";\nimport { useWaterfallStore } from \"../stores/waterfall\";\nimport { Vector3 } from \"three\";\nimport { chunkSize } from \"../constants\";\nimport WaterfallChunk from \"./WaterfallChunk\";\nimport { useGroundStore } from \"@features/ground/store\";\n\nexport default function Waterfalls() {\n  const size = useGroundStore((state) => state.size);\n  const setWaterfallChunks = useWaterfallStore(\n    (state) => state.setWaterfallChunks\n  );\n  const waterfallChunks = useWaterfallStore((state) => state.waterfallChunks);\n\n  useEffect(() => {\n    const origins = [];\n    for (let i = 0; i < size.x; i++) {\n      for (let j = 0; j < size.z; j++) {\n        for (let k = 0; k < size.z; k++) {\n          origins.push(new Vector3(i, j, k).multiplyScalar(chunkSize));\n        }\n      }\n    }\n    setWaterfallChunks(origins);\n  }, [size]);\n\n  return (\n    <>\n      {_.map(waterfallChunks, (chunk) => (\n        <WaterfallChunk key={chunk.key} origin={chunk.origin} />\n      ))}\n    </>\n  );\n}\n","/Users/will/wox/src/Water/Water.tsx",["280"],"import React from \"react\";\nimport _ from \"lodash\";\nimport { WaterChunk } from \"./WaterChunk\";\nimport { useGroundStore } from \"features/ground/store\";\n\nexport default function Water() {\n  const grounds = useGroundStore((state) => state.grounds);\n\n  return (\n    <>\n      {_.map(grounds, (ground) => (\n        <WaterChunk\n          key={ground.key}\n          origin={ground.origin}\n          version={ground.version}\n        />\n      ))}\n    </>\n  );\n}\n","/Users/will/wox/src/features/chunks/Mesher.tsx",["281"],"import { useEffect, useRef } from \"react\";\nimport ChunksData from \"./ChunksData\";\nimport Chunks from \"./components/Chunks\";\nimport React from \"react\";\nimport { useChunkStore } from \"./store\";\n\nexport default function Mesher() {\n  const chunksList = useChunkStore((state) => state.chunks);\n  const ref = useRef<number>();\n  const incrementVersion = useChunkStore((state) => state.incrementVersion);\n  const updateMeshData = useChunkStore((state) => state.updateMeshData);\n\n  const animate = () => {\n    handleFrame();\n    ref.current = requestAnimationFrame(animate);\n  };\n\n  useEffect(() => {\n    ref.current = requestAnimationFrame(animate);\n    return () => {\n      if (ref.current != null) {\n        cancelAnimationFrame(ref.current);\n      }\n    };\n  }, []);\n\n  const handleFrame = () => {\n    for (const chunks of chunksList) {\n      processChunks(chunks);\n\n      for (const id in chunks.map) {\n        let changed = false;\n        const chunk = chunks.map[id];\n        if (chunk.dirty) {\n          updateMeshData(chunk.layer, chunk.key);\n          chunk.dirty = false;\n          changed = true;\n        }\n\n        if (changed) {\n          incrementVersion(chunks.layer);\n        }\n      }\n    }\n  };\n\n  const processChunks = (chunks: ChunksData) => {\n    if (!chunks.dirty) {\n      return;\n    }\n\n    chunks.dirty = false;\n  };\n\n  return (\n    <>\n      {chunksList.map((chunks, index) => (\n        <Chunks key={index} layer={chunks.layer} />\n      ))}\n    </>\n  );\n}\n","/Users/will/wox/src/features/ground/store.ts",["282","283"],"import { Color, Vector3 } from \"three\";\nimport create from \"zustand\";\nimport Layers from \"../../Layers\";\nimport { Noise } from \"../../Noise\";\nimport Curve from \"../../utils/Curve\";\nimport { useChunkStore } from \"../chunks/store\";\nimport { useWaterStore } from \"../../stores/water\";\n\nexport interface GroundData {\n  key: string;\n  origin: Vector3;\n  version: number;\n}\n\nexport interface GroundState {\n  size: Vector3;\n  curve: Curve;\n  grounds: { [id: string]: GroundData };\n  addGrounds(origins: Vector3[]): void;\n  incrementVersion(id: string): void;\n  maxHeight: number;\n  rockColor: Color;\n  grassColor: Color;\n  generateGround(origin: Vector3): void;\n  generateGrass(origin: Vector3): void;\n  noise: Noise;\n  seed: string;\n}\n\nconst updateMeshData = useChunkStore.getState().updateMeshData;\n\nconst seed = \"1337\";\n\nexport const useGroundStore = create<GroundState>((set, get) => ({\n  noise: new Noise({\n    scale: new Vector3(1, 0.6, 1),\n    seed,\n  }),\n  size: new Vector3(3, 2, 3),\n  curve: new Curve([-1, -0.4, 0.2, 2], [-1, -0.58, -0.48, 1.5]),\n  grounds: {},\n  addGrounds(origins: Vector3[]) {\n    const grounds = { ...get().grounds };\n\n    for (const origin of origins) {\n      const key = origin.toArray().join(\",\");\n      if (grounds[key] == null) {\n        grounds[key] = {\n          key,\n          origin,\n          version: 0,\n        };\n      }\n    }\n\n    set({ grounds });\n  },\n  generateGround(origin: Vector3) {\n    const { rockColor, curve, noise, maxHeight } = get();\n    const chunks = useChunkStore.getState().chunks[Layers.ground];\n    const chunk = chunks.getOrCreateChunk(\n      origin.toArray() as [number, number, number]\n    );\n\n    chunk.getValueCallback = (i, j, k) => {\n      return getValue(\n        noise,\n        curve,\n        origin,\n        maxHeight,\n        i - origin.x,\n        j - origin.y,\n        k - origin.z\n      );\n    };\n\n    chunks.defaultColor = rockColor.toArray();\n    chunk.defaultColor = rockColor.toArray();\n\n    console.log(`Generated chunk ${chunk.key}`);\n\n    for (let i = 0; i < chunk.size; i++) {\n      for (let j = 0; j < chunk.size; j++) {\n        for (let k = 0; k < chunk.size; k++) {\n          chunk.setColor(i, j, k, rockColor.toArray());\n          const v = getValue(noise, curve, origin, maxHeight, i, j, k);\n          chunk.set(i, j, k, v);\n        }\n      }\n    }\n\n    updateMeshData(Layers.ground, chunk.key);\n  },\n  generateGrass(origin: Vector3) {\n    const chunks = useChunkStore.getState().chunks[Layers.ground];\n    const chunk = chunks.getOrCreateChunk(\n      origin.toArray() as [number, number, number]\n    );\n    const { waterLevel } = useWaterStore.getState();\n    const grassColor = get().grassColor.toArray();\n    const size = chunk.size;\n    const meshData = chunk.meshData!;\n    const voxels = meshData.voxels;\n\n    for (const voxel of voxels) {\n      const [i, j, k] = voxel.coord;\n      const absY = chunk.origin[1] + j;\n      if (absY <= waterLevel) {\n        continue;\n      }\n\n      const normal = voxel.voxelNormal;\n\n      const dot = new Vector3(0, -1, 0).dot(new Vector3().fromArray(normal));\n\n      if (dot > 0.75) {\n        chunk.setColor(i, j, k, grassColor);\n      }\n    }\n  },\n  incrementVersion(id: string) {\n    const grounds = { ...get().grounds };\n    grounds[id].version++;\n\n    set({ grounds });\n  },\n  maxHeight: 64,\n  rockColor: new Color(0.072, 0.08, 0.09),\n  grassColor: new Color(0.08, 0.1, 0.065),\n  seed,\n}));\n\nconst getValue = (\n  noise: Noise,\n  curve: Curve,\n  origin: Vector3,\n  maxHeight: number,\n  i: number,\n  j: number,\n  k: number\n) => {\n  const absY = origin.y + j;\n  const relY = absY / maxHeight;\n  const gradient = (-relY * 2 + 1) * 0.75;\n  const position = new Vector3().fromArray([i, j, k]).add(origin);\n  let nv = noise.get(position);\n  nv = curve.sample(nv);\n  const v = nv + gradient;\n  return v;\n};\n","/Users/will/wox/src/features/camera/components/CameraController.tsx",["284","285","286"],"import { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useThree } from \"react-three-fiber\";\nimport { Euler, Vector3 } from \"three\";\nimport { lerpEulers } from \"../../../utils/math\";\nimport { useCameraStore } from \"../store\";\n\nexport default () => {\n  const { camera } = useThree();\n\n  const target = useCameraStore((camera) => camera.target);\n  const distance = useCameraStore((camera) => camera.distance);\n  const targetRotation = useCameraStore((camera) => camera.targetRotation);\n  const rotation = useRef(targetRotation);\n\n  const updateCamera = useCallback(() => {\n    const rotationValue = new Euler(...rotation.current);\n    const targetValue = new Vector3(...target);\n    const position = new Vector3(0, 0, 1)\n      .applyEuler(rotationValue)\n      .multiplyScalar(distance)\n      .add(targetValue);\n    camera.position.copy(position);\n    camera.rotation.copy(rotationValue);\n    camera.lookAt(targetValue);\n  }, [target, distance]);\n\n  useEffect(() => {\n    updateCamera();\n  }, [updateCamera]);\n\n  const animate = useCallback(() => {\n    const rotationValue = new Euler(...rotation.current);\n    const nextRotation = lerpEulers(rotation.current, targetRotation, 0.5);\n    rotation.current = nextRotation;\n    ref.current = requestAnimationFrame(animate);\n    updateCamera();\n  }, [targetRotation]);\n\n  const ref = useRef<number>();\n\n  useEffect(() => {\n    ref.current = requestAnimationFrame(animate);\n    return () => {\n      if (ref.current != null) {\n        cancelAnimationFrame(ref.current);\n      }\n    };\n  }, [animate]);\n\n  return null;\n};\n","/Users/will/wox/src/features/ground/components/Ground/Ground.tsx",["287","288","289"],"import React, { useEffect, useMemo } from \"react\";\nimport { Vector2, Vector3 } from \"three\";\nimport { Noise } from \"../../../../Noise\";\nimport { chunkSize } from \"../../../../constants\";\nimport seedrandom from \"seedrandom\";\nimport { useGroundStore } from \"../../store\";\nimport _ from \"lodash\";\nimport GroundChunk from \"./GroundChunk\";\nimport { wait } from \"./wait\";\n\nexport interface GroundProps {\n  size: Vector3;\n  seed: number;\n}\n\nexport default function Ground(props: GroundProps) {\n  const { size, seed } = props;\n  const grounds = useGroundStore((state) => state.grounds);\n  const addGrounds = useGroundStore((state) => state.addGrounds);\n  const generateGround = useGroundStore((state) => state.generateGround);\n  const incrementVersion = useGroundStore((state) => state.incrementVersion);\n  const generateGrass = useGroundStore((state) => state.generateGrass);\n  const origins = useMemo(() => {\n    const origins: Vector3[] = [];\n    for (let i = 0; i < size.x; i++) {\n      for (let j = 0; j < size.y; j++) {\n        for (let k = 0; k < size.z; k++) {\n          origins.push(new Vector3(i, j, k).multiplyScalar(chunkSize));\n        }\n      }\n    }\n    return origins;\n  }, [size]);\n\n  const columns = useMemo(() => {\n    const columns: Vector2[] = [];\n    for (let i = 0; i < size.x; i++) {\n      for (let k = 0; k < size.z; k++) {\n        columns.push(new Vector2(i, k).multiplyScalar(chunkSize));\n      }\n    }\n    return columns;\n  }, []);\n\n  useEffect(() => {\n    addGrounds(origins);\n  }, [seed]);\n\n  useEffect(() => {\n    (async () => {\n      const start = new Date().getTime();\n      const center = new Vector2(size.x - 1, size.z - 1)\n        .multiplyScalar(0.5)\n        .multiplyScalar(chunkSize);\n\n      const sorted = columns.sort((a, b) => {\n        const dis1 = center.clone().sub(a).length();\n        const dis2 = center.clone().sub(b).length();\n        const result = dis1 - dis2;\n        return result;\n      });\n\n      for (const column of sorted) {\n        for (let j = 0; j < size.y; j++) {\n          const origin = new Vector3(column.x, j * chunkSize, column.y);\n          const id = origin.toArray().join(\",\");\n          generateGround(origin);\n          incrementVersion(id);\n          generateGrass(origin);\n        }\n        await wait(0);\n      }\n      console.log(`Took ${new Date().getTime() - start}ms`);\n    })();\n  }, []);\n\n  return (\n    <>\n      {_.map(grounds, (ground) => (\n        <GroundChunk key={ground.key} origin={ground.origin} id={ground.key} />\n      ))}\n    </>\n  );\n}\n","/Users/will/wox/src/stores/light.ts",[],"/Users/will/wox/src/features/camera/store.ts",[],"/Users/will/wox/src/stores/input.ts",[],"/Users/will/wox/src/raycast.ts",["290"],"import { Vector2, Camera, Scene, Raycaster, Vector3 } from \"three\";\nimport ChunksData from \"./features/chunks/ChunksData\";\nimport { HoverState } from \"./HoverState\";\nimport getFaceInfo from \"./features/chunks/getFaceInfo\";\n\nconst raycast = (\n  mouse: Vector2,\n  camera: Camera,\n  scene: Scene,\n  chunks: ChunksData[],\n  layers: number[]\n) => {\n  const ray = new Raycaster();\n  for (const layer of layers) {\n    ray.layers.disableAll();\n    ray.layers.enable(layer + 1);\n  }\n\n  ray.setFromCamera(mouse, camera);\n  const intersects = ray.intersectObjects(scene.children);\n  if (intersects.length === 0) {\n    return;\n  }\n\n  const intersect = intersects[0];\n  const userData = intersect.object.userData;\n  if (!userData.isChunkMesh) {\n    return;\n  }\n\n  const { origin, layer } = userData;\n  const faceIndex = intersect.faceIndex;\n  if (faceIndex == null) {\n    return;\n  }\n\n  const chunk = chunks[layer].getChunk(origin);\n  if (chunk == null || chunk.meshData == null) {\n    return;\n  }\n\n  const face = getFaceInfo(chunk.meshData, faceIndex);\n  if (face == null) {\n    return;\n  }\n\n  if (chunk.meshData == null) {\n    return;\n  }\n\n  const voxel = chunk.meshData.voxels[face.voxelIndex];\n  const worldCoord = new Vector3()\n    .fromArray(chunk.origin)\n    .add(new Vector3().fromArray(voxel.coord));\n\n  return {\n    coord: worldCoord.toArray() as [number, number, number],\n    layer,\n    face,\n    voxel,\n  } as HoverState;\n};\n\nexport default raycast;\n","/Users/will/wox/src/Grid/constants.ts",[],"/Users/will/wox/src/Layers.ts",[],"/Users/will/wox/src/features/chunks/store.ts",["291"],"import create from \"zustand\";\nimport ChunksData from \"./ChunksData\";\nimport { chunkSize } from \"../../constants\";\nimport Layers from \"../../Layers\";\nimport { meshChunk } from \"./meshChunk\";\nimport { useWaterStore } from \"../../stores/water\";\n\nexport interface ChunksState {\n  chunks: ChunksData[];\n  versions: number[];\n  chunkVersions: { [layer: number]: { [id: string]: number } };\n  incrementVersion(layer: number): void;\n  updateMeshData(layer: number, id: string): void;\n}\n\nconst treesChunk = new ChunksData(chunkSize, Layers.trees);\ntreesChunk.normalBias = 0.8;\n\nconst waterChunk = new ChunksData(chunkSize, Layers.water);\nwaterChunk.isWater = true;\nwaterChunk.normalBias = 1.0;\nwaterChunk.skyBias = 1.0;\nwaterChunk.offset = [0, -0.5, 0];\n\nconst structureChunks = new ChunksData(chunkSize, Layers.structures);\nstructureChunks.renderAllSurfaces = true;\n\nconst chunks = [\n  new ChunksData(chunkSize, Layers.ground),\n  treesChunk,\n  waterChunk,\n  structureChunks,\n];\n\nexport const useChunkStore = create<ChunksState>((set, get) => ({\n  chunks,\n  versions: chunks.map((_) => 0),\n  chunkVersions: {},\n  incrementVersion(layer: number) {\n    const versions = [...get().versions];\n    versions[layer]++;\n\n    set({ versions });\n  },\n  updateMeshData(layer: number, id: string) {\n    const waterLevel = useWaterStore.getState().waterLevel;\n    const start = new Date().getTime();\n    const chunk = chunks[layer].map[id];\n    const meshData = meshChunk(chunk, waterLevel);\n    chunk.meshData = meshData;\n    const end = new Date().getTime();\n\n    console.log(\n      `Meshed ${layer} ${chunk.origin.join(\",\")} ${\n        meshData.vertices.length / 3\n      } vertices, ${meshData.indices.length / 3} triangles ${end - start}ms`\n    );\n\n    const chunkVersions = { ...get().chunkVersions };\n    if (chunkVersions[layer] == null) {\n      chunkVersions[layer] = {};\n    }\n    const byChunk = chunkVersions[layer];\n\n    if (byChunk[chunk.key] == null) {\n      byChunk[chunk.key] = 0;\n    }\n\n    byChunk[chunk.key]++;\n\n    set({ chunkVersions });\n  },\n}));\n","/Users/will/wox/src/stores/grid.ts",["292"],"import create from \"zustand\";\nimport { Vector2, Vector3 } from \"three\";\nimport { useGroundStore } from \"features/ground/store\";\nimport { chunkSize } from \"../constants\";\nimport { useChunkStore } from \"../features/chunks/store\";\nimport Layers from \"../Layers\";\nimport { gridSize } from \"../Grid/constants\";\nimport { useWaterStore } from \"./water\";\nimport _ from \"lodash\";\n\nexport interface GridData {\n  id: string;\n  origin: Vector2;\n  coords: Vector3[];\n  minY: number;\n  maxY: number;\n}\n\nexport interface GridColumnData {\n  id: string;\n  origin: Vector2;\n  gridIds: string[];\n}\n\nexport interface GridState {\n  grids: { [id: string]: GridData };\n  gridColumns: { [id: string]: GridColumnData };\n  setGrids(columnId: string, grids: GridData[]): void;\n  addGridColumns(origins: Vector2[]): void;\n  gridIds: string[];\n  setGridIds(gridIds: string[]): void;\n  generateGrids(origin: Vector2): void;\n}\n\nexport const useGridStore = create<GridState>((set, get) => ({\n  setGrids(columnId: string, grids: GridData[]) {\n    const existingGrids = { ...get().grids };\n    for (const grid of grids) {\n      existingGrids[grid.id] = grid;\n    }\n    set({ grids: existingGrids });\n\n    const gridColumns = { ...get().gridColumns };\n    gridColumns[columnId].gridIds = grids.map((x) => x.id);\n    set({ gridColumns });\n  },\n  addGridColumns(origins: Vector2[]) {\n    const gridColumns = { ...get().gridColumns };\n    for (const origin of origins) {\n      const id = origin.toArray().join(\",\");\n      gridColumns[id] = {\n        id,\n        origin,\n        gridIds: [],\n      };\n    }\n    set({ gridColumns });\n  },\n  grids: {},\n  gridColumns: {},\n  gridIds: [],\n  setGridIds(gridIds: string[]) {\n    set({ gridIds });\n  },\n  generateGrids(origin: Vector2) {\n    const size = useGroundStore.getState().size;\n    const groundChunks = useChunkStore.getState().chunks[Layers.ground];\n    const waterLevel = useWaterStore.getState().waterLevel;\n    const setGrids = get().setGrids;\n    const grids: { [id: string]: GridData } = {};\n\n    for (let j = 0; j < size.y; j++) {\n      const co = new Vector3(origin.x, j * chunkSize, origin.y);\n      const chunk = groundChunks.getChunk(\n        co.toArray() as [number, number, number]\n      );\n\n      const meshData = chunk.meshData!;\n\n      for (const faceIndex of meshData.upFaces) {\n        const face = meshData.faces[faceIndex];\n        const voxel = meshData.voxels[face.voxelIndex];\n        const coord = new Vector3().fromArray(voxel.coord).add(co);\n        if (coord.y <= waterLevel) {\n          continue;\n        }\n        const go = new Vector2(\n          Math.floor(coord.x / gridSize) * gridSize,\n          Math.floor(coord.z / gridSize) * gridSize\n        );\n        const key = go.toArray().join(\",\");\n        if (grids[key] == null) {\n          grids[key] = {\n            id: go.toArray().join(\",\"),\n            origin: go,\n            coords: [],\n            minY: 0,\n            maxY: 0,\n          };\n        }\n        grids[key].coords.push(coord);\n      }\n    }\n\n    for (const key in grids) {\n      const grid = grids[key];\n      const ys = grid.coords.map((g) => g.y);\n      grid.minY = _(ys).min() || 0;\n      grid.maxY = _(ys).max() || 0;\n    }\n\n    const key = origin.toArray().join(\",\");\n    setGrids(key, _.values(grids));\n  },\n}));\n","/Users/will/wox/src/stores/structure.ts",[],"/Users/will/wox/src/Structure.tsx",["293"],"import { useEffect } from \"react\";\nimport placeStructure from \"./Brushes/placeStructure\";\nimport { useGridStore } from \"./stores/grid\";\nimport { useChunkStore } from \"./features/chunks/store\";\n\nexport interface StructureProps {\n  gridIds: string[];\n}\n\nexport default function Structure({ gridIds }: StructureProps) {\n  const grids = useGridStore((state) => state.grids);\n  const chunks = useChunkStore((state) => state.chunks);\n\n  useEffect(() => {\n    const gs = gridIds.map((x) => grids[x]);\n    placeStructure(chunks, gs);\n  }, []);\n  return null;\n}\n","/Users/will/wox/src/constants.ts",[],"/Users/will/wox/src/stores/waterfall.ts",["294"],"import create from \"zustand\";\nimport { Vector3 } from \"three\";\nimport { useChunkStore } from \"../features/chunks/store\";\nimport Layers from \"../Layers\";\nimport seedrandom from \"seedrandom\";\nimport { clamp } from \"lodash\";\nimport { Noise } from \"../Noise\";\nimport traceWaterfall from \"../Waterfalls/traceWaterfall\";\nimport { useWaterStore } from \"./water\";\nimport { useGroundStore } from \"@features/ground/store\";\n\nexport interface WaterfallPoint {\n  coord: Vector3;\n  value: number;\n}\n\nexport interface WaterfallData {\n  key: string;\n  position: Vector3;\n  points: WaterfallPoint[];\n}\n\nexport interface WaterfallChunkData {\n  key: string;\n  origin: Vector3;\n  waterfallIds: string[];\n}\n\nexport interface WaterfallState {\n  waterfalls: { [key: string]: WaterfallData };\n  waterfallChunks: { [key: string]: WaterfallChunkData };\n  generateWaterfalls(origin: Vector3): void;\n  setWaterfallChunks(origins: Vector3[]): void;\n  noise: Noise;\n}\n\nconst seed = useGroundStore.getState().seed + \"waterfall\";\n\nexport const useWaterfallStore = create<WaterfallState>((set, get) => ({\n  waterfalls: {},\n  waterfallChunks: {},\n  seed,\n  noise: new Noise({\n    seed,\n    frequency: 0.01,\n  }),\n  generateWaterfalls(origin: Vector3) {\n    const { maxHeight } = useGroundStore.getState();\n    const waterLevel = useWaterStore.getState().waterLevel;\n    const groundChunks = useChunkStore.getState().chunks[Layers.ground];\n    const chunk = groundChunks.getChunk(\n      origin.toArray() as [number, number, number]\n    );\n    const rng = seedrandom(seed + \"generateWaterfalls\" + chunk.key);\n    const meshData = chunk.meshData!;\n    const noise = get().noise;\n\n    if (meshData.upFaces.length === 0) {\n      return;\n    }\n\n    const density = 1 / 420;\n\n    const waterfallChunks = { ...get().waterfallChunks };\n    const waterfalls = { ...get().waterfalls };\n\n    const key = origin.toArray().join(\",\");\n    const waterfallChunk = {\n      key,\n      origin,\n      waterfallIds: [],\n    } as WaterfallChunkData;\n    waterfallChunks[key] = waterfallChunk;\n\n    for (let i = 0; i < meshData.upFaces.length * density; i++) {\n      const index = Math.floor(meshData.upFaces.length * rng());\n      const faceIndex = meshData.upFaces[index];\n      const face = meshData.faces[faceIndex];\n      const voxel = meshData.voxels[face.voxelIndex];\n\n      const position = new Vector3().fromArray(voxel.coord).add(origin);\n      const relY = 1 - position.y / maxHeight;\n      const yFactor = clamp((relY - 0.5) * 2, 0, 1);\n\n      const v = -Math.abs(noise.get(position)) * yFactor;\n\n      if (v < 0) {\n        continue;\n      }\n\n      console.log(`Trace waterfall ${position.toArray().join(\",\")}`);\n      const result = traceWaterfall(position, groundChunks, waterLevel);\n\n      if (!result.reachedWater) {\n        continue;\n      }\n\n      const points = result.points;\n      const waterfall = {\n        key: position.toArray().join(\",\"),\n        position,\n        points,\n      };\n\n      waterfallChunk.waterfallIds.push(waterfall.key);\n      waterfalls[waterfall.key] = waterfall;\n    }\n\n    set({\n      waterfallChunks,\n      waterfalls,\n    });\n  },\n  setWaterfallChunks(origins: Vector3[]) {\n    const waterfallChunks = { ...get().waterfallChunks };\n    for (const origin of origins) {\n      const key = origin.toArray().join(\",\");\n      waterfallChunks[key] = {\n        key,\n        origin,\n        waterfallIds: [],\n      };\n\n      set({ waterfallChunks });\n    }\n  },\n}));\n","/Users/will/wox/src/stores/water.ts",["295"],"import { Color, Vector3 } from \"three\";\nimport create from \"zustand\";\nimport Layers from \"../Layers\";\nimport { useChunkStore } from \"../features/chunks/store\";\n\nexport interface WaterState {\n  waterLevel: number;\n  waterColor: Color;\n  waterAlpha: number;\n  generateWater(origin: Vector3): void;\n}\n\nexport const useWaterStore = create((set, get) => ({\n  waterColor: new Color(0.08, 0.12, 0.2),\n  waterAlpha: 0.4,\n  waterLevel: 6,\n  generateWater(origin: Vector3) {\n    const { waterLevel, waterColor } = get();\n    const chunksList = useChunkStore.getState().chunks;\n    const groundChunks = chunksList[Layers.ground];\n    const waterChunks = chunksList[Layers.water];\n\n    if (origin.y > waterLevel) {\n      return;\n    }\n\n    const groundChunk = groundChunks.getChunk(\n      origin.toArray() as [number, number, number]\n    );\n    const chunk = waterChunks.getOrCreateChunk(\n      origin.toArray() as [number, number, number]\n    );\n\n    for (let i = 0; i < chunk.size; i++) {\n      for (let j = 0; j < chunk.size; j++) {\n        for (let k = 0; k < chunk.size; k++) {\n          const absY = j + origin.y;\n          if (absY > waterLevel) {\n            chunk.set(i, j, k, 0);\n            continue;\n          }\n          const v = groundChunk.get(i, j, k)!;\n          if (v > 0) {\n            chunk.set(i, j, k, 0);\n            continue;\n          }\n          chunk.set(i, j, k, 1);\n          chunk.setColor(i, j, k, waterColor.toArray());\n        }\n      }\n    }\n  },\n}));\n","/Users/will/wox/src/utils/math.ts",["296","297","298","299","300"],"import { Vector3, Quaternion } from \"three\";\n\nexport type EulerValue = [number, number, number, string];\nexport type Vector3Value = [number, number, number];\n\nexport const lerp = (a: number, b: number, r: number) => {\n  return a + (b - a) * r;\n};\n\nexport const lerpEulers = (\n  a: EulerValue,\n  b: EulerValue,\n  r: number\n): EulerValue => {\n  return [lerp(a[0], b[0], r), lerp(a[1], b[1], r), lerp(a[2], b[2], r), a[3]];\n};\n\nexport const clamp = (v: number, min: number, max: number) => {\n  if (v < min) {\n    return min;\n  }\n  if (v > max) {\n    return max;\n  }\n  return v;\n};\n\nexport const calcSphereStroke = (radius: number) => {\n  const r = Math.ceil(radius);\n\n  const result = [];\n  for (let i = -r; i <= r; i++) {\n    for (let j = -r; j <= r; j++) {\n      for (let k = -r; k <= r; k++) {\n        const dis = Math.sqrt(i * i + j * j + k * k);\n        const value = 1 - dis / radius;\n        if (value < 0) {\n          continue;\n        }\n        result.push({\n          coord: new Vector3(i, j, k),\n          value,\n        });\n      }\n    }\n  }\n\n  return result;\n};\n\nexport const randomVector = (rng: seedrandom.prng) => {\n  const a = 2 * Math.PI * rng();\n  const z = rng() * 2 - 1;\n  const r = Math.sqrt(1 - z * z);\n  return new Vector3(r * Math.cos(a), r * Math.sin(a), z);\n};\n\nexport const randomQuaternion = (rng: seedrandom.prng) => {\n  return new Quaternion().setFromUnitVectors(\n    new Vector3(0, 1, 0),\n    randomVector(rng)\n  );\n};\n","/Users/will/wox/src/utils/Curve.ts",["301"],"class Curve {\n  intervals: number[] = [-1, 1];\n  values: number[] = [-1, 1];\n\n  constructor(intervals?: number[], values?: number[]) {\n    if (intervals != null) {\n      this.intervals = intervals;\n    }\n\n    if (values != null) {\n      this.values = values;\n    }\n  }\n\n  sample(interval: number) {\n    if (interval < this.intervals[0]) {\n      return this.values[0];\n    }\n\n    if (interval > this.intervals[this.intervals.length - 1]) {\n      return this.values[this.intervals.length - 1];\n    }\n\n    for (let i = 0; i < this.intervals.length - 1; i++) {\n      const i1 = this.intervals[i];\n      const i2 = this.intervals[i + 1];\n      if (interval >= i1 && interval <= i2) {\n        const v1 = this.values[i];\n        const v2 = this.values[i + 1];\n\n        const r = (interval - i1) / (i2 - i1);\n\n        return v1 * (1 - r) + v2 * r;\n      }\n    }\n\n    throw new Error(\"out of range!\");\n  }\n}\n\nexport default Curve;\n","/Users/will/wox/src/Grid/GridChunk.tsx",["302","303"],"import { Vector2, Vector3 } from \"three\";\nimport { useCallback, useEffect } from \"react\";\nimport { chunkSize } from \"../constants\";\nimport _ from \"lodash\";\nimport { useGridStore } from \"../stores/grid\";\nimport { useGroundStore } from \"features/ground/store\";\n\ninterface GridChunkProps {\n  origin: Vector2;\n}\n\nexport default function GridChunk({\n  origin,\n}: GridChunkProps) {\n  const grounds = useGroundStore((state) => state.grounds);\n  const generateGrids = useGridStore((state) => state.generateGrids);\n\n  const generated = useGroundStore(\n    useCallback(\n      (state) => {\n        for (let j = 0; j < state.size.y; j++) {\n          const co = new Vector3(origin.x, j * chunkSize, origin.y);\n          const key = co.toArray().join(\",\");\n          const ground = state.grounds[key];\n          if (ground.version === 0) {\n            return false;\n          }\n        }\n\n        return true;\n      },\n      [grounds]\n    )\n  );\n\n  useEffect(() => {\n    if (!generated) {\n      return;\n    }\n\n    generateGrids(origin);\n  }, [generated]);\n\n  return null;\n}\n","/Users/will/wox/src/Trees/TreeChunk.tsx",["304"],"import { useEffect } from \"react\";\nimport { Vector3 } from \"three\";\nimport { useTreeStore } from \"../stores/tree\";\nimport React from \"react\";\nimport _ from \"lodash\";\nimport Tree from \"./Tree\";\n\nexport interface TreeChunkProps {\n  origin: Vector3;\n  version: number;\n}\n\nexport function TreeChunk({ version, origin }: TreeChunkProps) {\n  const key = origin.toArray().join(\",\");\n  const generateTrees = useTreeStore((state) => state.generateTrees);\n  const trees = useTreeStore((state) => state.trees[key]);\n\n  useEffect(() => {\n    if (version === 0) {\n      return;\n    }\n    console.log(`Generate trees for ${origin.toArray().join(\",\")}`);\n    generateTrees(origin);\n  }, [version]);\n\n  return (\n    <>\n      {_.map(trees, (tree) => (\n        <Tree key={tree.key} position={tree.position} normal={tree.normal} size={tree.size}/>\n      ))}\n    </>\n  );\n}\n","/Users/will/wox/src/Water/WaterChunk.tsx",["305"],"import { useEffect } from \"react\";\nimport { Vector3 } from \"three\";\nimport { useWaterStore } from \"../stores/water\";\n\nexport interface WaterChunkProps {\n  origin: Vector3;\n  version: number;\n}\n\nexport function WaterChunk({ origin, version }: WaterChunkProps) {\n  const generateWater = useWaterStore((state) => state.generateWater);\n\n  useEffect(() => {\n    if (version === 0) {\n      return;\n    }\n    generateWater(origin);\n\n    console.log(`Generate water ${origin.toArray().join(\",\")}`);\n  }, [version]);\n  return null;\n}\n","/Users/will/wox/src/Waterfalls/WaterfallChunk.tsx",["306"],"import { Waterfall } from \"./Waterfall\";\nimport { Vector3 } from \"three\";\nimport { useWaterfallStore } from \"../stores/waterfall\";\nimport { useCallback, useEffect } from \"react\";\nimport React from \"react\";\nimport { useGroundStore } from \"features/ground/store\";\n\ninterface WaterfallChunkProps {\n  origin: Vector3;\n}\n\nexport default function WaterfallChunk({ origin }: WaterfallChunkProps) {\n  const generateWaterfalls = useWaterfallStore(\n    (state) => state.generateWaterfalls\n  );\n\n  const key = origin.toArray().join(\",\");\n  const groundVersion = useGroundStore(\n    (state) => state.grounds[key]?.version ?? 0\n  );\n  const waterfallIds = useWaterfallStore(\n    (state) => state.waterfallChunks[key].waterfallIds\n  );\n\n  const waterfalls = useWaterfallStore(\n    useCallback((state) => waterfallIds.map((id) => state.waterfalls[id]), [\n      waterfallIds,\n    ])\n  );\n\n  useEffect(() => {\n    if (groundVersion === 0) {\n      return;\n    }\n    generateWaterfalls(origin);\n  }, [groundVersion]);\n\n  return (\n    <>\n      {waterfalls.map((waterfall) => (\n        <Waterfall key={waterfall.key} data={waterfall} />\n      ))}\n    </>\n  );\n}\n","/Users/will/wox/src/Noise.tsx",["307","308","309"],"import SimplexNoise from \"simplex-noise\";\nimport { Vector3 } from \"three\";\n\nexport interface NoiseOptions {\n  seed?: SimplexNoise.RandomNumberGenerator | string;\n  frequency?: number;\n  scale?: Vector3;\n  type?: NoiseType;\n  octaves?: number;\n  persistence?: number;\n  lacunarity?: number;\n}\n\nexport enum NoiseType {\n  fbm\n}\n\nexport class Noise {\n  seed: SimplexNoise.RandomNumberGenerator | string;\n  frequency: number;\n  scale: Vector3;\n  type: NoiseType;\n  octaves: number;\n  persistence: number;\n  lacunarity: number;\n\n  noise: SimplexNoise;\n  constructor(options?: NoiseOptions) {\n    this.seed = options?.seed || Math.random;\n    this.frequency = options?.frequency || 0.01;\n    this.scale = options?.scale || new Vector3(1, 1, 1);\n    this.type = options?.type || NoiseType.fbm;\n    this.octaves = options?.octaves || 5;\n    this.persistence = options?.persistence || 0.5;\n    this.lacunarity = options?.lacunarity || 2;\n\n    this.noise = new SimplexNoise(this.seed);\n  }\n\n  get(coord: Vector3) {\n    switch (this.type) {\n      case NoiseType.fbm:\n        return this.getFbm(coord);\n    }\n  }\n\n  getFbm(coord: Vector3) {\n    let v = 0;\n    let a = 1;\n    let f = this.frequency;\n\n    for (let i = 0; i < this.octaves; i++) {\n      v += this.getSimplex(coord, f) * a;\n      f *= this.lacunarity;\n      a *= this.persistence;\n    }\n\n    return v;\n  }\n\n  getSimplex(coord: Vector3, frequency: number) {\n    return this.noise.noise3D(\n      coord.x * frequency * this.scale.x,\n      coord.y * frequency * this.scale.y,\n      coord.z * frequency * this.scale.z);\n  }\n}\n","/Users/will/wox/src/features/ground/components/Ground/GroundChunk.tsx",["310","311","312","313","314","315","316","317","318","319"],"import { useEffect } from \"react\";\nimport { Color, Vector3 } from \"three\";\nimport Layers from \"../../../../Layers\";\nimport { Noise } from \"../../../../Noise\";\nimport { useChunkStore } from \"../../../chunks/store\";\nimport { useGroundStore } from \"../../store\";\nimport Curve from \"../../../../utils/Curve\";\n\nexport interface GroundChunkProps {\n  origin: Vector3;\n  id: string;\n}\n\nexport default function GroundChunk({ id, origin }: GroundChunkProps) {\n  return null;\n}\n","/Users/will/wox/src/features/ground/components/Ground/wait.tsx",["320"],"export function wait(ms: number) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve();\n    }, ms);\n  });\n}\n","/Users/will/wox/src/features/chunks/components/Chunks.tsx",["321","322"],"import React, { useMemo } from \"react\";\nimport _ from \"lodash\";\nimport Chunk from \"./Chunk\";\nimport { useChunkStore } from \"../store\";\n\nexport interface ChunksProps {\n  layer: number;\n}\n\nexport default function Chunks({ layer }: ChunksProps) {\n  const chunks = useChunkStore((state) => state.chunks[layer]);\n  const version = useChunkStore((state) => state.versions[layer]);\n\n  console.log(`Rerender chunks version: ${version}`);\n\n  return (\n    <>\n      {_.values(chunks.map).map((chunk) => {\n        return <Chunk key={chunk.key} chunk={chunk} />;\n      })}\n    </>\n  );\n}\n","/Users/will/wox/src/features/chunks/getFaceInfo.ts",[],"/Users/will/wox/src/features/chunks/ChunksData.ts",["323","324","325","326","327","328","329","330","331"],"import ChunkData from \"./ChunkData\";\n\nexport default class ChunksData {\n  map: { [key: string]: ChunkData } = {};\n  size: number;\n  dirty = false;\n  layer: number;\n  normalBias = 0.5;\n  skyBias = 0.5;\n  isWater = false;\n  offset = [0, 0, 0];\n  hasBounds = false;\n  renderAllSurfaces = false;\n  defaultColor: number[] = [0, 0, 0];\n\n  constructor(size: number, layer = 0) {\n    this.size = size;\n    this.layer = layer;\n  }\n\n  get(i: number, j: number, k: number) {\n    const origin = this.getOrigin(i, j, k);\n    const chunk = this.getChunk(origin);\n    if (chunk == null) {\n      return null;\n    }\n    return chunk.get(i - origin[0], j - origin[1], k - origin[2]);\n  }\n\n  set(i: number, j: number, k: number, v: number) {\n    const origin = this.getOrigin(i, j, k);\n    const chunk = this.getOrCreateChunk(origin);\n    return chunk.set(i - origin[0], j - origin[1], k - origin[2], v);\n  }\n\n  setColor(i: number, j: number, k: number, color: number[]) {\n    if (i < 0 || j < 0 || k < 0) {\n      return;\n    }\n    const origin = this.getOrigin(i, j, k);\n    const chunk = this.getOrCreateChunk(origin);\n    return chunk.setColor(i - origin[0], j - origin[1], k - origin[2], color);\n  }\n\n  getColor(i: number, j: number, k: number) {\n    const origin = this.getOrigin(i, j, k);\n    const chunk = this.getChunk(origin);\n    if (chunk == null) {\n      return this.defaultColor;\n    }\n    return chunk.getColor(i - origin[0], j - origin[1], k - origin[2]);\n  }\n\n  getOrigin(i: number, j: number, k: number): [number, number, number] {\n    return [\n      Math.floor(i / this.size) * this.size,\n      Math.floor(j / this.size) * this.size,\n      Math.floor(k / this.size) * this.size,\n    ];\n  }\n\n  getKey(origin: [number, number, number]) {\n    return origin.join(\",\");\n  }\n\n  getChunk(origin: [number, number, number]) {\n    const key = this.getKey(origin);\n    return this.map[key];\n  }\n\n  getOrCreateChunk(origin: [number, number, number]) {\n    const key = this.getKey(origin);\n    if (this.map[key] == null) {\n      const chunk = new ChunkData(origin, this, this.size, this.layer);\n      this.map[key] = chunk;\n      chunk.isWater = this.isWater;\n      this.dirty = true;\n    }\n    return this.map[key];\n  }\n\n  visitChunk(callback: (chunk: ChunkData) => void) {\n    for (const key in this.map) {\n      callback(this.map[key]);\n    }\n  }\n\n  isSurface(i: number, j: number, k: number) {\n    return (\n      (this.get(i, j, k) ?? 0) > 0 &&\n      ((this.get(i + 1, j, k) ?? 0) < 0 ||\n        (this.get(i - 1, j, k) ?? 0) < 0 ||\n        (this.get(i, j + 1, k) ?? 0) < 0 ||\n        (this.get(i, j - 1, k) ?? 0) < 0 ||\n        (this.get(i, j, k + 1) ?? 0) < 0 ||\n        (this.get(i, j, k - 1) ?? 0) < 0)\n    );\n  }\n}\n","/Users/will/wox/src/features/chunks/meshChunk.ts",[],"/Users/will/wox/src/Waterfalls/traceWaterfall.ts",["332","333","334"],"import { Vector2, Vector3 } from \"three\";\nimport ChunksData from \"../features/chunks/ChunksData\";\nimport { WaterfallPoint } from \"../stores/waterfall\";\n\nconst ring = [\n  new Vector2(-1, -1),\n  new Vector2(0, -1),\n  new Vector2(1, -1),\n  new Vector2(-1, 1),\n  new Vector2(0, 1),\n  new Vector2(1, 1),\n  new Vector2(-1, 0),\n  new Vector2(1, 0),\n];\n\nexport interface TraceWaterfallResult {\n  points: WaterfallPoint[];\n  reachedWater: boolean;\n}\n\nconst traceWaterfall = (\n  position: Vector3,\n  groundChunks: ChunksData,\n  waterLevel: number\n): TraceWaterfallResult => {\n  let count = 0;\n\n  const value = groundChunks.get(position.x, position.y, position.z)!;\n  let pointer: WaterfallPoint = {\n    coord: position,\n    value,\n  };\n\n  const results: WaterfallPoint[] = [pointer];\n\n  let reachedWater = false;\n  do {\n    const next = findNext(pointer.coord, groundChunks);\n    if (next == null) {\n      break;\n    }\n    results.push(next);\n    if (next.coord.y <= waterLevel) {\n      reachedWater = true;\n      break;\n    }\n    pointer = next;\n    count++;\n  } while (count < 100);\n\n  return {\n    points: results,\n    reachedWater,\n  };\n};\n\nconst findNext = (\n  from: Vector3,\n  groundChunks: ChunksData\n): WaterfallPoint | null => {\n  const downEmpty = findDownEmpty(from, groundChunks);\n  if (downEmpty != null) {\n    console.log(\"down empty\");\n    return downEmpty;\n  }\n\n  const downSolid = findDownSolid(from, groundChunks);\n  if (downSolid != null) {\n    return downSolid;\n  }\n\n  const first = findInRing(from, groundChunks, -1);\n  if (first === \"never\") {\n    return null;\n  }\n\n  if (first != null) {\n    console.log(\"found point in first ring\");\n    return first;\n  }\n\n  const second = findInRing(from, groundChunks, 0);\n\n  if (second === \"never\") {\n    return null;\n  }\n\n  if (second != null) {\n    console.log(\"found point in second ring\");\n    return second;\n  }\n\n  console.log(\"not found\");\n  return null;\n};\n\nconst findInRing = (\n  from: Vector3,\n  groundChunks: ChunksData,\n  y: number\n): WaterfallPoint | null | \"never\" => {\n  const results: WaterfallPoint[] = [];\n  const v = groundChunks.get(from.x, from.y, from.z)!;\n\n  for (const point of ring) {\n    const coord = from.clone().add(new Vector3(point.x, y, point.y));\n\n    const value = groundChunks.get(coord.x, coord.y, coord.z);\n\n    if (value == null) {\n      return \"never\";\n    }\n\n    if (!groundChunks.isSurface(coord.x, coord.y, coord.z)) {\n      continue;\n    }\n\n    if (value < 0) {\n      continue;\n    }\n\n    if (y === 0 && value > v) {\n      continue;\n    }\n\n    results.push({\n      coord,\n      value,\n    });\n  }\n\n  const result =\n    results.sort((a, b) => {\n      return a.value - b.value;\n    })[0] ?? null;\n\n  if (result == null) {\n    return null;\n  }\n\n  return result;\n};\n\nconst findDownEmpty = (from: Vector3, groundChunks: ChunksData) => {\n  const down = from.clone().add(new Vector3(0, -1, 0));\n  const downV = groundChunks.get(down.x, down.y, down.z);\n\n  if (downV == null) {\n    return null;\n  }\n\n  if (downV < 0) {\n    return {\n      coord: down,\n      value: downV,\n    };\n  }\n\n  return null;\n};\n\nconst findDownSolid = (\n  from: Vector3,\n  groundChunks: ChunksData\n): WaterfallPoint | null => {\n  const down = from.clone().add(new Vector3(0, -1, 0));\n  if (groundChunks.isSurface(down.x, down.y, down.z)) {\n    const value = groundChunks.get(down.x, down.y, down.z)!;\n    return {\n      coord: down,\n      value,\n    };\n  }\n\n  return null;\n};\n\nexport default traceWaterfall;\n","/Users/will/wox/src/Brushes/placeStructure.tsx",["335","336"],"import ChunksData from \"../features/chunks/ChunksData\";\nimport { Vector3, Color, Euler } from \"three\";\nimport Layers from \"../Layers\";\nimport seedrandom from \"seedrandom\";\nimport { GridData } from \"../stores/grid\";\nimport _ from \"lodash\";\n\nexport default (chunksList: ChunksData[], grids: GridData[]) => {\n  const hw = 3;\n  const hl = 3;\n  const height = 7;\n  const doorHeight = 4;\n  const lower = new Vector3(-hw, -1, -hl);\n  const upper = new Vector3(hw, height, hl);\n\n  const minY = _(grids)\n    .map((grid) => grid.coords)\n    .flatten()\n    .minBy((coord) => coord.y)!.y;\n\n  const origins = grids.map((grid) => grid.origin);\n  const coord = new Vector3(\n    _(origins)\n      .map((origin) => origin.x)\n      .min(),\n    0,\n    _(origins)\n      .map((origin) => origin.y)\n      .min()\n  );\n\n  const offset = new Vector3(hw, minY, hl);\n\n  const chunks = chunksList[Layers.structures];\n  const rng = seedrandom();\n  const rotation = new Euler(\n    0,\n    (Math.PI / 2) * Math.floor(rng() * 4),\n    0,\n    \"YXZ\"\n  );\n\n  for (let x = lower.x; x <= upper.x; x++) {\n    for (let y = lower.y; y <= upper.y; y++) {\n      for (let z = lower.z; z <= upper.z; z++) {\n        const p = new Vector3(x, y, z);\n        p.applyEuler(rotation);\n        p.x = Math.round(p.x);\n        p.y = Math.round(p.y);\n        p.z = Math.round(p.z);\n\n        const i = p.x;\n        const j = p.y;\n        const k = p.z;\n\n        const isChimney = i == 1 && k == 1 && j > 3;\n\n        const disCorner = hw - Math.abs(i) + (height - j);\n\n        if (disCorner < hw && !isChimney) {\n          continue;\n        }\n\n        if (j < height - hw - 1 && Math.abs(i) == hw) {\n          continue;\n        }\n\n        const isRoof = disCorner === hw;\n        const isDoor = i == 0 && j < doorHeight && (k === hl || k === -hl);\n        const roofHue = k % 2;\n\n        const worldCoord = new Vector3(x, y, z).add(coord).add(offset);\n        chunks.set(worldCoord.x, worldCoord.y, worldCoord.z, 1);\n\n        let color;\n        if (isChimney) {\n          color = new Color(0.12, 0.13, 0.15);\n        } else if (isRoof) {\n          color = new Color(0.1, 0.1, 0.1).multiplyScalar(\n            roofHue === 0 ? 0.85 : 1.0\n          );\n        } else if (isDoor) {\n          color = new Color(0.1, 0.1, 0.1);\n        } else {\n          color = new Color(0.18, 0.18, 0.18);\n        }\n\n        chunks.setColor(\n          worldCoord.x,\n          worldCoord.y,\n          worldCoord.z,\n          color.toArray()\n        );\n      }\n    }\n  }\n};\n","/Users/will/wox/src/stores/tree.ts",["337","338"],"import { Vector3 } from \"three\";\nimport create from \"zustand\";\nimport Layers from \"../Layers\";\nimport { Noise } from \"../Noise\";\nimport QuadMap from \"../utils/QuadMap\";\nimport { useChunkStore } from \"../features/chunks/store\";\nimport seedrandom from \"seedrandom\";\nimport { useWaterStore } from \"./water\";\nimport { useGroundStore } from \"@features/ground/store\";\n\nexport interface TreeData {\n  key: string;\n  normal: Vector3;\n  size: number;\n  position: Vector3;\n}\n\nconst seed = useGroundStore.getState().seed;\nconst noise = new Noise({\n  frequency: 0.0025,\n  seed: seed + \"tree\",\n});\n\nexport interface TreeState {\n  treeMap: QuadMap<TreeData>;\n  noise: Noise;\n  generateTrees(origin: Vector3): void;\n  trees: { [id: string]: { [key: string]: TreeData } };\n}\n\nexport const useTreeStore = create<TreeState>((set, get) => ({\n  treeMap: new QuadMap(),\n  noise: noise,\n  trees: {},\n  generateTrees(origin: Vector3) {\n    const chunk = useChunkStore\n      .getState()\n      .chunks[Layers.ground].getChunk(\n        origin.toArray() as [number, number, number]\n      );\n    const { noise, treeMap } = get();\n    const { maxHeight } = useGroundStore.getState();\n    const waterLevel = useWaterStore.getState().waterLevel;\n    const rng = seedrandom(seed + \"generateTrees\" + origin.toArray().join(\",\"));\n\n    const meshData = chunk.meshData!;\n\n    if (meshData.faces.length === 0) {\n      return;\n    }\n\n    const minDistance = 6;\n\n    const chunkKey = origin.toArray().join(\",\");\n    const treesInChunk: { [id: string]: TreeData } = {};\n    const trees = { ...get().trees };\n    trees[chunkKey] = treesInChunk;\n\n    for (let i = 0; i < meshData.upFaces.length / 24; i++) {\n      const index = Math.floor(meshData.upFaces.length * rng());\n      const faceIndex = meshData.upFaces[index];\n      const face = meshData.faces[faceIndex];\n\n      const voxel = meshData.voxels[face.voxelIndex];\n      const position = new Vector3().fromArray(voxel.coord).add(origin);\n      if (position.y < waterLevel + 3) {\n        continue;\n      }\n      const relY = position.y / maxHeight;\n      // const yFactor = Math.pow(1 - relY, 0.9);\n      const voxelNormal = voxel.voxelNormal;\n      // const up = 1 - clamp(new Vector3(0, -1, 0).dot(voxelNormal), 0, 1);\n      const nv = noise.get(position);\n      //const v = -Math.abs(nv) * yFactor * up + 0.2;\n      const v = -Math.abs(nv) + 0.4;\n      if (v < 0) {\n        continue;\n      }\n\n      const size = 1 + Math.pow(rng(), 1.5) * 0.5;\n      const otherTrees = treeMap.find(position, minDistance * size);\n\n      if (otherTrees.length === 0) {\n        const tree = {\n          key: position.toArray().join(\",\"),\n          normal: new Vector3().fromArray(voxelNormal),\n          size,\n          position,\n        };\n        treeMap.set(position, tree);\n        treesInChunk[position.toArray().join(\",\")] = tree;\n      }\n    }\n\n    set({ trees });\n  },\n}));\n","/Users/will/wox/src/Trees/Tree.tsx",["339"],"import { useEffect } from \"react\";\nimport { Vector3 } from \"three\";\nimport Layers from \"../Layers\";\nimport { useChunkStore } from \"../features/chunks/store\";\nimport placeTree from \"./placeTree\";\n\nexport interface TreeProps {\n  position: Vector3;\n  normal: Vector3;\n  size: number;\n}\n\nexport default function Tree({ position: coord, normal, size }: TreeProps) {\n  const chunks = useChunkStore((state) => state.chunks[Layers.trees]);\n\n  useEffect(() => {\n    placeTree(chunks, coord, normal, size);\n  }, []);\n\n  return null;\n}\n","/Users/will/wox/src/Waterfalls/Waterfall.tsx",["340","341"],"import { useEffect } from \"react\";\nimport Layers from \"../Layers\";\nimport { Color } from \"three\";\nimport ChunksData from \"../features/chunks/ChunksData\";\nimport { useChunkStore } from \"../features/chunks/store\";\nimport { useWaterStore } from \"../stores/water\";\nimport { WaterfallData, WaterfallPoint } from \"../stores/waterfall\";\n\nexport interface WaterfallProps {\n  data: WaterfallData;\n}\n\nexport function Waterfall({ data }: WaterfallProps) {\n  const groundChunks = useChunkStore((state) => state.chunks[Layers.ground]);\n  const waterColor = useWaterStore((state) => state.waterColor);\n\n  useEffect(() => {\n    applyWaterfall(data.points, groundChunks, waterColor);\n  }, []);\n\n  return null;\n}\n\nconst applyWaterfall = (\n  points: WaterfallPoint[],\n  groundChunks: ChunksData,\n  waterColor: Color\n) => {\n  for (const pointer of points) {\n    const coord = pointer.coord;\n    const v = groundChunks.get(coord.x, coord.y, coord.z)!;\n    if (v < 0) {\n      groundChunks.set(coord.x, coord.y, coord.z, 1);\n    }\n\n    groundChunks.setColor(\n      coord.x,\n      coord.y,\n      coord.z,\n      waterColor.toArray() as [number, number, number]\n    );\n  }\n};\n","/Users/will/wox/src/features/chunks/components/Chunk.tsx",["342"],"import ChunkData from \"../ChunkData\";\nimport React, { useEffect, useRef } from \"react\";\n\nimport {\n  BufferGeometry,\n  DataTexture,\n  Uniform,\n  RGBFormat,\n  FloatType,\n  Vector3,\n  ShaderMaterial,\n  UniformsUtils,\n  UniformsLib,\n  BufferAttribute,\n  Mesh,\n  Material,\n} from \"three\";\nimport _ from \"lodash\";\nimport { vertexShader, fragmentShader } from \"../voxelShader\";\nimport { useChunkStore } from \"../store\";\nimport { useWaterStore } from \"../../../stores/water\";\nimport { useLightStore } from \"../../../stores/light\";\n\nexport interface ChunkProps {\n  chunk: ChunkData;\n}\n\nfunction Chunk(props: ChunkProps) {\n  const { chunk } = props;\n\n  const meshRef = useRef(new Mesh());\n  const sunColor = useLightStore((state) => state.sunColor);\n  const ambient = useLightStore((state) => state.ambient);\n  const waterAlpha = useWaterStore((state) => state.waterAlpha);\n  const lightDir = useLightStore.getState().lightDir;\n  const version = useChunkStore((state) => {\n    const versions = state.chunkVersions[chunk.layer] || {};\n    return versions[chunk.key] ?? 0;\n  });\n\n  console.log(\n    `Rerender chunk ${props.chunk.layer} ${props.chunk.origin.join(\",\")}`\n  );\n\n  const handleLightDirChanged = (lightDir: Vector3) => {\n    console.log(\"handle light dir changed\");\n    const mesh = meshRef.current;\n    const material = mesh.material as ShaderMaterial;\n    material.uniforms.lightDir = new Uniform(lightDir);\n    material.uniformsNeedUpdate = true;\n    material.needsUpdate = true;\n  };\n\n  useEffect(\n    () =>\n      useLightStore.subscribe(\n        (lightDir) => handleLightDirChanged(lightDir as Vector3),\n        (state) => state.lightDir\n      ),\n    []\n  );\n\n  useEffect(() => {\n    const position = new Vector3()\n      .fromArray(chunk.origin)\n      .add(new Vector3().fromArray(chunk.chunks.offset));\n    const mesh = meshRef.current;\n    mesh.position.copy(position);\n    mesh.receiveShadow = true;\n    mesh.castShadow = true;\n    mesh.userData = {\n      isChunkMesh: true,\n      origin: chunk.origin,\n      layer: chunk.layer,\n    };\n\n    const uniforms = UniformsUtils.merge([\n      UniformsLib[\"lights\"],\n      {\n        sunColor: new Uniform(sunColor),\n        lightDir: new Uniform(lightDir),\n        ambient: new Uniform(ambient),\n        normalBias: new Uniform(chunk.chunks.normalBias),\n        skyBias: new Uniform(chunk.chunks.skyBias),\n        waterAlpha: new Uniform(waterAlpha),\n        isWater: new Uniform(chunk.chunks.isWater ? 1.0 : 0.0),\n      },\n    ]);\n\n    mesh.material = new ShaderMaterial({\n      vertexShader,\n      fragmentShader,\n      lights: true,\n      uniforms,\n      transparent: chunk.chunks.isWater,\n    });\n  }, []);\n\n  useEffect(() => {\n    const meshData = chunk.meshData;\n\n    console.log(`Update chunk ${chunk.layer} ${chunk.key}`);\n\n    if (meshData == null) {\n      return;\n    }\n\n    const mesh = meshRef.current;\n    mesh.layers.enable(chunk.layer + 1);\n\n    if (mesh.geometry != null) {\n      mesh.geometry.dispose();\n    }\n\n    const geometry = new BufferGeometry();\n    geometry.setIndex(meshData.indices);\n    geometry.setAttribute(\n      \"position\",\n      new BufferAttribute(new Float32Array(meshData.vertices), 3)\n    );\n    geometry.setAttribute(\n      \"color\",\n      new BufferAttribute(new Float32Array(meshData.colors), 3)\n    );\n    geometry.setAttribute(\n      \"normal\",\n      new BufferAttribute(new Float32Array(meshData.normals), 3)\n    );\n    geometry.setAttribute(\n      \"voxelIndex\",\n      new BufferAttribute(new Uint32Array(meshData.voxelIndexes), 1)\n    );\n    geometry.setAttribute(\n      \"ao\",\n      new BufferAttribute(new Float32Array(meshData.ao), 1)\n    );\n\n    mesh.geometry = geometry;\n\n    const material = mesh.material as ShaderMaterial;\n\n    const prevTexture = material.uniforms.voxelNormals?.value;\n    if (prevTexture != null) {\n      prevTexture.dispose();\n    }\n\n    const voxelNormals = meshData.voxelNormals;\n    if (voxelNormals.length > 0) {\n      const textureSize = voxelNormals.length / 3;\n      const dataTexture = new DataTexture(\n        Float32Array.from(voxelNormals),\n        textureSize,\n        1,\n        RGBFormat,\n        FloatType\n      );\n\n      material.uniforms.voxelNormals = new Uniform(dataTexture);\n    }\n\n    material.uniforms.voxelCount = new Uniform(meshData.voxelCount);\n    material.uniformsNeedUpdate = true;\n    material.needsUpdate = true;\n  }, [version]);\n\n  useEffect(() => {\n    return () => {\n      const mesh = meshRef.current;\n      const material = mesh.material as ShaderMaterial;\n      const texture = material.uniforms.voxelNormals?.value;\n      if (texture != null) {\n        texture.dispose();\n      }\n      if (mesh.geometry != null) {\n        mesh.geometry.dispose();\n      }\n      if (mesh.material != null) {\n        (mesh.material as Material).dispose();\n      }\n    };\n  }, []);\n\n  return <primitive object={meshRef.current} />;\n}\n\nexport default React.memo(Chunk);\n","/Users/will/wox/src/features/chunks/ChunkData.ts",["343","344","345","346"],"import ChunksData from \"./ChunksData\";\nimport { MeshData } from \"./MeshData\";\n\ntype getValueFunction = (i: number, j: number, k: number) => number | null;\n\nexport default class ChunkData {\n  data: number[] = [];\n  color: number[][] = [];\n  origin: [number, number, number];\n  size: number;\n  chunks: ChunksData;\n  meshData: MeshData | null = null;\n  dirty = false;\n  key: string;\n  layer: number;\n  isWater = false;\n  getValueCallback: getValueFunction;\n  defaultColor: number[] = [0, 0, 0];\n\n  constructor(\n    origin: [number, number, number],\n    chunks: ChunksData,\n    size: number,\n    layer: number\n  ) {\n    this.origin = origin;\n    this.size = size;\n    this.chunks = chunks;\n    this.layer = layer;\n    this.key = this.getKey();\n    this.getValueCallback = this.chunks.get.bind(this.chunks);\n  }\n\n  get(i: number, j: number, k: number): number | null {\n    if (\n      i < 0 ||\n      j < 0 ||\n      k < 0 ||\n      i >= this.size ||\n      j >= this.size ||\n      k >= this.size\n    ) {\n      return 0;\n    }\n    const index = i * this.size * this.size + j * this.size + k;\n    return this.data[index] ?? null;\n  }\n\n  getWorld(i: number, j: number, k: number): number | null {\n    if (\n      i < 0 ||\n      j < 0 ||\n      k < 0 ||\n      i >= this.size ||\n      j >= this.size ||\n      k >= this.size\n    ) {\n      return this.getValueCallback(\n        i + this.origin[0],\n        j + this.origin[1],\n        k + this.origin[2]\n      );\n    }\n\n    return this.get(i, j, k);\n  }\n\n  set(i: number, j: number, k: number, v: number) {\n    const index = i * this.size * this.size + j * this.size + k;\n    this.data[index] = v;\n    this.dirty = true;\n  }\n\n  setColor(i: number, j: number, k: number, color: number[]) {\n    const index = i * this.size * this.size + j * this.size + k;\n    this.color[index] = color;\n    this.dirty = true;\n  }\n\n  getColor(i: number, j: number, k: number) {\n    const index = i * this.size * this.size + j * this.size + k;\n    const color = this.color[index];\n    if (color == null) {\n      return this.defaultColor;\n    }\n    return [...color];\n  }\n\n  getColorWorld(i: number, j: number, k: number) {\n    if (\n      i < 0 ||\n      j < 0 ||\n      k < 0 ||\n      i >= this.size ||\n      j >= this.size ||\n      k >= this.size\n    ) {\n      return this.chunks.getColor(\n        i + this.origin[0],\n        j + this.origin[1],\n        k + this.origin[2]\n      );\n    }\n\n    return this.getColor(i, j, k);\n  }\n\n  private getKey() {\n    return this.origin.join(\",\");\n  }\n\n  calcNormal(i: number, j: number, k: number): [number, number, number] {\n    const normal = [\n      (this.getWorld(i + 1, j, k) ?? 0) - (this.getWorld(i - 1, j, k) ?? 0),\n      (this.getWorld(i, j + 1, k) ?? 0) - (this.getWorld(i, j - 1, k) ?? 0),\n      (this.getWorld(i, j, k + 1) ?? 0) - (this.getWorld(i, j, k - 1) ?? 0),\n    ] as [number, number, number];\n    return normalize(normal);\n  }\n}\n\nexport const normalize = (\n  coord: [number, number, number]\n): [number, number, number] => {\n  const [i, j, k] = coord;\n  const dis = Math.sqrt(i * i + j * j + k * k);\n  return [i / dis, j / dis, k / dis];\n};\n","/Users/will/wox/src/utils/QuadMap.ts",["347","348","349","350","351"],"import { Vector2, Vector3 } from \"three\";\n\nconst intersectRectangle = (point: Vector2, min: Vector2, max: Vector2) => {\n  return (\n    point.x >= min.x && point.x <= max.x && point.y >= min.y && point.y <= max.y\n  );\n};\n\nexport default class QuadMap<T> {\n  columns: { [id: string]: QuadChunk<T> } = {};\n  size = 32;\n  version = 0;\n\n  set(position: Vector3, value: T) {\n    const origin = this.getOrigin(position);\n    const chunk = this.getOrCreateChunk(origin);\n    chunk.set(position, value);\n    this.version++;\n  }\n\n  get(position: Vector3): T | undefined {\n    const origin = this.getOrigin(position);\n    const chunk = this.getChunk(origin);\n    return chunk.get(position);\n  }\n\n  find(position: Vector3, distance: number): T[] {\n    const origins = this.getOriginsToSearch(position, distance);\n    const results: T[] = [];\n\n    for (const origin of origins) {\n      const chunk = this.getChunk(origin);\n      if (chunk == null) {\n        continue;\n      }\n      for (const id in chunk.items) {\n        const entry = chunk.items[id];\n        const dis = entry.position.distanceTo(position);\n        if (dis < distance) {\n          results.push(entry.value);\n        }\n      }\n    }\n\n    return results;\n  }\n\n  getOriginsToSearch(position: Vector3, distance: number) {\n    const origin = this.getOrigin(position);\n\n    const origins = [origin];\n\n    for (let i = -1; i <= 1; i++) {\n      for (let j = -1; j <= 1; j++) {\n        const chunk = origin\n          .clone()\n          .add(new Vector2(i, j).multiplyScalar(this.size));\n\n        if (i === 0 && j === 0) {\n          continue;\n        }\n\n        const min = chunk.clone().add(new Vector2(-distance, -distance));\n        const rect = {\n          min,\n          max: min\n            .clone()\n            .add(new Vector2(this.size, this.size))\n            .add(new Vector2(distance, distance)),\n        };\n        const result = intersectRectangle(\n          new Vector2(position.x, position.z),\n          rect.min,\n          rect.max\n        );\n        if (result) {\n          origins.push(chunk);\n        }\n      }\n    }\n\n    return origins;\n  }\n\n  private getOrigin(position: Vector3) {\n    return new Vector2(\n      Math.floor(position.x / this.size) * this.size,\n      Math.floor(position.z / this.size) * this.size\n    );\n  }\n\n  private getOrCreateChunk(origin: Vector2) {\n    const key = `${origin.x},${origin.y}`;\n    let chunk = this.columns[key];\n    if (chunk != null) {\n      return chunk;\n    }\n\n    chunk = new QuadChunk(origin);\n    this.columns[key] = chunk;\n\n    return chunk;\n  }\n\n  private getChunk(origin: Vector2) {\n    const key = `${origin.x},${origin.y}`;\n    return this.columns[key];\n  }\n\n  visit(callback: (entry: T) => void) {\n    for (const key in this.columns) {\n      this.columns[key].visit(callback);\n    }\n  }\n}\n\nexport class QuadChunk<T> {\n  origin: Vector2;\n  key: string;\n\n  constructor(origin: Vector2) {\n    this.origin = origin;\n    this.key = this.origin.toArray().join(\",\");\n  }\n\n  items: { [key: string]: Entry<T> } = {};\n  set(position: Vector3, value: T) {\n    const key = this.getKey(position);\n    this.items[key] = {\n      position,\n      value,\n    };\n  }\n  get(position: Vector3): T | undefined {\n    const key = this.getKey(position);\n    return this.items[key].value;\n  }\n  private getKey(position: Vector3) {\n    return `${position.x},${position.y},${position.z}`;\n  }\n  visit(callback: (entry: T) => void) {\n    for (const key in this.items) {\n      callback(this.items[key].value);\n    }\n  }\n}\n\nexport interface Entry<T> {\n  position: Vector3;\n  value: T;\n}\n","/Users/will/wox/src/Trees/placeTree.ts",["352"],"import ChunksData from \"../features/chunks/ChunksData\";\nimport { Vector3, Quaternion, Matrix4, Vector2, Color } from \"three\";\nimport { clamp } from \"lodash\";\nimport { sdVerticalCapsule, opTx, sdCone } from \"../utils/sdf\";\nimport { Bounds } from \"../utils/Bounds\";\n\nconst placeTree = (\n  chunks: ChunksData,\n  coord: Vector3,\n  voxelNormal: Vector3,\n  size: number,\n  bounds?: Bounds\n) => {\n  const lower = new Vector3(-5, -2, -5);\n  const upper = new Vector3(5, 18, 5);\n  const leafColor = new Color(0.06, 0.09, 0.04);\n  const trunkColor = new Color(0.05, 0.05, 0.05);\n\n  for (let i = lower.x; i <= upper.x; i++) {\n    for (let j = lower.y; j <= upper.y; j++) {\n      for (let k = lower.z; k <= upper.z; k++) {\n        const p = new Vector3(i, j, k);\n\n        const rotation = new Quaternion().setFromUnitVectors(\n          new Vector3(0, 1, 0),\n          new Vector3(0, 1, 0).lerp(voxelNormal.clone().multiplyScalar(-1), 0.35)\n        );\n\n        const trunkM = new Matrix4().compose(\n          new Vector3(),\n          rotation,\n          new Vector3(1, 1, 1)\n        );\n        const coneHeight = 10 * size;\n        const height = 12 * size;\n        const trunkHeight = coneHeight * 0.5;\n\n        const trunk = clamp(\n          -sdVerticalCapsule(opTx(p, trunkM), trunkHeight, 0.6),\n          0,\n          1\n        );\n\n        const leafsM = new Matrix4().compose(\n          new Vector3(0, height, 0).applyQuaternion(rotation),\n          rotation,\n          new Vector3(1, 1, 1)\n        );\n        const leafs = clamp(\n          -sdCone(opTx(p, leafsM), new Vector2(3.7, 1.0), coneHeight),\n          0,\n          1\n        );\n\n        const worldCoord = coord.clone().add(p);\n        if (trunk < 0 && leafs < 0) {\n          continue;\n        }\n\n        const value = chunks.get(worldCoord.x, worldCoord.y, worldCoord.z) ?? 0;\n\n        if (value > 0) {\n          continue;\n        }\n\n        const isLeafs = leafs > trunk;\n\n        if (bounds != null) {\n          if (\n            worldCoord.x > bounds.max.x ||\n            worldCoord.x < bounds.min.x ||\n            worldCoord.y > bounds.max.y ||\n            worldCoord.y < bounds.min.y ||\n            worldCoord.z > bounds.max.z ||\n            worldCoord.z < bounds.min.z\n          ) {\n            continue;\n          }\n        }\n\n        chunks.set(\n          worldCoord.x,\n          worldCoord.y,\n          worldCoord.z,\n          Math.max(value, trunk, leafs)\n        );\n\n        if (isLeafs) {\n          chunks.setColor(worldCoord.x, worldCoord.y, worldCoord.z, leafColor.toArray());\n        } else {\n          chunks.setColor(worldCoord.x, worldCoord.y, worldCoord.z, trunkColor.toArray());\n        }\n      }\n    }\n  }\n};\n\nexport default placeTree;\n","/Users/will/wox/src/features/chunks/voxelShader.ts",[],"/Users/will/wox/src/utils/sdf.ts",["353","354"],"import { Vector3, Vector2, Matrix4 } from \"three\";\nimport { clamp } from \"lodash\";\n\ntype vec3 = Vector3;\n\nconst abs = (value: Vector3) => {\n  return new Vector3(Math.abs(value.x), Math.abs(value.y), Math.abs(value.z));\n};\n\nconst maxVector3 = (a: Vector3, b: number) => {\n  return new Vector3(Math.max(a.x, b), Math.max(a.y, b), Math.max(a.z, b));\n};\n\nconst max = Math.max;\n\nconst min = Math.min;\n\nconst length = (vector: Vector3) => {\n  return vector.length();\n};\n\nexport const opTx = (p: Vector3, t: Matrix4): Vector3 => {\n  return p.clone().applyMatrix4(new Matrix4().getInverse(t));\n};\n\nexport const sdVerticalCapsule = (p: Vector3, h: number, r: number): number => {\n  p = p.clone();\n  p.y -= clamp(p.y, 0.0, h);\n  return p.length() - r;\n};\n\nexport const sdCone = (p: Vector3, c: Vector2, h: number): number => {\n  const q = Math.sqrt(p.x * p.x + p.z * p.z);\n  return Math.max(new Vector2(c.x, c.y).dot(new Vector2(q, p.y)), -h - p.y);\n};\n\nexport const sdBox = (p: vec3, b: vec3) => {\n  const q = new Vector3().subVectors(abs(p), b);\n  return length(maxVector3(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n};\n\nexport const sdSphere = (p: vec3, s: number) => {\n  return length(p) - s;\n};\n",[],{"ruleId":"355","severity":1,"message":"356","line":1,"column":17,"nodeType":"357","messageId":"358","endLine":1,"endColumn":26},{"ruleId":"355","severity":1,"message":"359","line":6,"column":10,"nodeType":"357","messageId":"358","endLine":6,"endColumn":17},{"ruleId":"355","severity":1,"message":"360","line":10,"column":8,"nodeType":"357","messageId":"358","endLine":10,"endColumn":22},{"ruleId":"355","severity":1,"message":"361","line":11,"column":10,"nodeType":"357","messageId":"358","endLine":11,"endColumn":19},{"ruleId":"355","severity":1,"message":"362","line":12,"column":8,"nodeType":"357","messageId":"358","endLine":12,"endColumn":19},{"ruleId":"355","severity":1,"message":"363","line":13,"column":8,"nodeType":"357","messageId":"358","endLine":13,"endColumn":18},{"ruleId":"355","severity":1,"message":"364","line":14,"column":10,"nodeType":"357","messageId":"358","endLine":14,"endColumn":19},{"ruleId":"355","severity":1,"message":"365","line":15,"column":8,"nodeType":"357","messageId":"358","endLine":15,"endColumn":14},{"ruleId":"355","severity":1,"message":"366","line":16,"column":8,"nodeType":"357","messageId":"358","endLine":16,"endColumn":17},{"ruleId":"355","severity":1,"message":"367","line":17,"column":8,"nodeType":"357","messageId":"358","endLine":17,"endColumn":17},{"ruleId":"355","severity":1,"message":"368","line":18,"column":8,"nodeType":"357","messageId":"358","endLine":18,"endColumn":17},{"ruleId":"369","severity":1,"message":"370","line":31,"column":16,"nodeType":"371","messageId":"372","endLine":31,"endColumn":21},{"ruleId":"369","severity":1,"message":"370","line":6,"column":16,"nodeType":"371","messageId":"372","endLine":6,"endColumn":21},{"ruleId":"373","severity":1,"message":"374","line":27,"column":15,"nodeType":"375","messageId":"376","endLine":29,"endColumn":8},{"ruleId":"369","severity":1,"message":"370","line":7,"column":16,"nodeType":"371","messageId":"372","endLine":7,"endColumn":21},{"ruleId":"369","severity":1,"message":"370","line":6,"column":16,"nodeType":"371","messageId":"372","endLine":6,"endColumn":21},{"ruleId":"369","severity":1,"message":"370","line":22,"column":16,"nodeType":"377","messageId":"372","endLine":22,"endColumn":40},{"ruleId":"369","severity":1,"message":"370","line":5,"column":16,"nodeType":"377","messageId":"372","endLine":5,"endColumn":41},{"ruleId":"369","severity":1,"message":"370","line":6,"column":16,"nodeType":"377","messageId":"372","endLine":6,"endColumn":37},{"ruleId":"369","severity":1,"message":"370","line":10,"column":16,"nodeType":"377","messageId":"372","endLine":10,"endColumn":32},{"ruleId":"369","severity":1,"message":"370","line":6,"column":16,"nodeType":"377","messageId":"372","endLine":6,"endColumn":32},{"ruleId":"369","severity":1,"message":"370","line":9,"column":16,"nodeType":"377","messageId":"372","endLine":9,"endColumn":37},{"ruleId":"369","severity":1,"message":"370","line":6,"column":16,"nodeType":"377","messageId":"372","endLine":6,"endColumn":32},{"ruleId":"369","severity":1,"message":"370","line":7,"column":16,"nodeType":"377","messageId":"372","endLine":7,"endColumn":33},{"ruleId":"355","severity":1,"message":"378","line":101,"column":11,"nodeType":"357","messageId":"358","endLine":101,"endColumn":15},{"ruleId":"373","severity":1,"message":"374","line":102,"column":22,"nodeType":"375","messageId":"376","endLine":102,"endColumn":37},{"ruleId":"355","severity":1,"message":"379","line":1,"column":42,"nodeType":"357","messageId":"358","endLine":1,"endColumn":50},{"ruleId":"369","severity":1,"message":"370","line":7,"column":16,"nodeType":"371","messageId":"372","endLine":7,"endColumn":21},{"ruleId":"355","severity":1,"message":"380","line":32,"column":11,"nodeType":"357","messageId":"358","endLine":32,"endColumn":24},{"ruleId":"355","severity":1,"message":"381","line":3,"column":10,"nodeType":"357","messageId":"358","endLine":3,"endColumn":15},{"ruleId":"355","severity":1,"message":"382","line":5,"column":8,"nodeType":"357","messageId":"358","endLine":5,"endColumn":18},{"ruleId":"369","severity":1,"message":"370","line":16,"column":16,"nodeType":"377","messageId":"372","endLine":16,"endColumn":51},{"ruleId":"369","severity":1,"message":"370","line":6,"column":17,"nodeType":"371","messageId":"372","endLine":12,"endColumn":5},{"ruleId":"355","severity":1,"message":"383","line":37,"column":25,"nodeType":"357","messageId":"358","endLine":37,"endColumn":26},{"ruleId":"373","severity":1,"message":"374","line":78,"column":24,"nodeType":"375","messageId":"376","endLine":78,"endColumn":39},{"ruleId":"369","severity":1,"message":"370","line":10,"column":16,"nodeType":"377","messageId":"372","endLine":10,"endColumn":63},{"ruleId":"373","severity":1,"message":"374","line":55,"column":22,"nodeType":"375","messageId":"376","endLine":55,"endColumn":37},{"ruleId":"373","severity":1,"message":"374","line":42,"column":21,"nodeType":"375","messageId":"376","endLine":42,"endColumn":46},{"ruleId":"369","severity":1,"message":"370","line":6,"column":21,"nodeType":"371","messageId":"372","endLine":6,"endColumn":57},{"ruleId":"369","severity":1,"message":"370","line":18,"column":22,"nodeType":"371","messageId":"372","endLine":18,"endColumn":62},{"ruleId":"369","severity":1,"message":"370","line":28,"column":33,"nodeType":"371","messageId":"372","endLine":28,"endColumn":52},{"ruleId":"369","severity":1,"message":"370","line":51,"column":29,"nodeType":"371","messageId":"372","endLine":51,"endColumn":54},{"ruleId":"369","severity":1,"message":"370","line":58,"column":33,"nodeType":"371","messageId":"372","endLine":58,"endColumn":58},{"ruleId":"369","severity":1,"message":"370","line":15,"column":3,"nodeType":"384","messageId":"372","endLine":15,"endColumn":27},{"ruleId":"355","severity":1,"message":"383","line":4,"column":8,"nodeType":"357","messageId":"358","endLine":4,"endColumn":9},{"ruleId":"369","severity":1,"message":"370","line":12,"column":16,"nodeType":"377","messageId":"372","endLine":14,"endColumn":19},{"ruleId":"369","severity":1,"message":"370","line":13,"column":8,"nodeType":"377","messageId":"372","endLine":13,"endColumn":63},{"ruleId":"369","severity":1,"message":"370","line":10,"column":8,"nodeType":"377","messageId":"372","endLine":10,"endColumn":65},{"ruleId":"369","severity":1,"message":"370","line":12,"column":16,"nodeType":"377","messageId":"372","endLine":12,"endColumn":72},{"ruleId":"369","severity":1,"message":"370","line":40,"column":3,"nodeType":"384","messageId":"372","endLine":40,"endColumn":22},{"ruleId":"369","severity":1,"message":"370","line":47,"column":3,"nodeType":"384","messageId":"372","endLine":47,"endColumn":25},{"ruleId":"369","severity":1,"message":"370","line":61,"column":3,"nodeType":"384","messageId":"372","endLine":61,"endColumn":48},{"ruleId":"355","severity":1,"message":"356","line":1,"column":10,"nodeType":"357","messageId":"358","endLine":1,"endColumn":19},{"ruleId":"355","severity":1,"message":"385","line":2,"column":10,"nodeType":"357","messageId":"358","endLine":2,"endColumn":15},{"ruleId":"355","severity":1,"message":"365","line":3,"column":8,"nodeType":"357","messageId":"358","endLine":3,"endColumn":14},{"ruleId":"355","severity":1,"message":"381","line":4,"column":10,"nodeType":"357","messageId":"358","endLine":4,"endColumn":15},{"ruleId":"355","severity":1,"message":"386","line":5,"column":10,"nodeType":"357","messageId":"358","endLine":5,"endColumn":23},{"ruleId":"355","severity":1,"message":"387","line":6,"column":10,"nodeType":"357","messageId":"358","endLine":6,"endColumn":24},{"ruleId":"355","severity":1,"message":"388","line":7,"column":8,"nodeType":"357","messageId":"358","endLine":7,"endColumn":13},{"ruleId":"369","severity":1,"message":"370","line":14,"column":16,"nodeType":"377","messageId":"372","endLine":14,"endColumn":70},{"ruleId":"355","severity":1,"message":"389","line":14,"column":39,"nodeType":"357","messageId":"358","endLine":14,"endColumn":41},{"ruleId":"355","severity":1,"message":"390","line":14,"column":43,"nodeType":"357","messageId":"358","endLine":14,"endColumn":49},{"ruleId":"369","severity":1,"message":"370","line":1,"column":8,"nodeType":"377","messageId":"372","endLine":1,"endColumn":33},{"ruleId":"355","severity":1,"message":"391","line":1,"column":17,"nodeType":"357","messageId":"358","endLine":1,"endColumn":24},{"ruleId":"369","severity":1,"message":"370","line":10,"column":16,"nodeType":"377","messageId":"372","endLine":10,"endColumn":55},{"ruleId":"369","severity":1,"message":"370","line":21,"column":3,"nodeType":"384","messageId":"372","endLine":21,"endColumn":39},{"ruleId":"369","severity":1,"message":"370","line":30,"column":3,"nodeType":"384","messageId":"372","endLine":30,"endColumn":50},{"ruleId":"369","severity":1,"message":"370","line":36,"column":3,"nodeType":"384","messageId":"372","endLine":36,"endColumn":61},{"ruleId":"369","severity":1,"message":"370","line":45,"column":3,"nodeType":"384","messageId":"372","endLine":45,"endColumn":44},{"ruleId":"369","severity":1,"message":"370","line":62,"column":3,"nodeType":"384","messageId":"372","endLine":62,"endColumn":43},{"ruleId":"369","severity":1,"message":"370","line":66,"column":3,"nodeType":"384","messageId":"372","endLine":66,"endColumn":45},{"ruleId":"369","severity":1,"message":"370","line":71,"column":3,"nodeType":"384","messageId":"372","endLine":71,"endColumn":53},{"ruleId":"369","severity":1,"message":"370","line":82,"column":3,"nodeType":"384","messageId":"372","endLine":82,"endColumn":51},{"ruleId":"369","severity":1,"message":"370","line":88,"column":3,"nodeType":"384","messageId":"372","endLine":88,"endColumn":45},{"ruleId":"373","severity":1,"message":"374","line":28,"column":17,"nodeType":"375","messageId":"376","endLine":28,"endColumn":70},{"ruleId":"373","severity":1,"message":"374","line":103,"column":13,"nodeType":"375","messageId":"376","endLine":103,"endColumn":54},{"ruleId":"373","severity":1,"message":"374","line":168,"column":19,"nodeType":"375","messageId":"376","endLine":168,"endColumn":60},{"ruleId":"369","severity":1,"message":"370","line":8,"column":16,"nodeType":"371","messageId":"372","endLine":8,"endColumn":64},{"ruleId":"373","severity":1,"message":"374","line":16,"column":16,"nodeType":"375","messageId":"376","endLine":19,"endColumn":32,"suggestions":"392"},{"ruleId":"373","severity":1,"message":"374","line":46,"column":22,"nodeType":"375","messageId":"376","endLine":46,"endColumn":37},{"ruleId":"355","severity":1,"message":"393","line":69,"column":13,"nodeType":"357","messageId":"358","endLine":69,"endColumn":17},{"ruleId":"369","severity":1,"message":"370","line":13,"column":16,"nodeType":"377","messageId":"372","endLine":13,"endColumn":75},{"ruleId":"369","severity":1,"message":"370","line":13,"column":8,"nodeType":"377","messageId":"372","endLine":13,"endColumn":52},{"ruleId":"373","severity":1,"message":"374","line":31,"column":15,"nodeType":"375","messageId":"376","endLine":31,"endColumn":59},{"ruleId":"355","severity":1,"message":"383","line":18,"column":8,"nodeType":"357","messageId":"358","endLine":18,"endColumn":9},{"ruleId":"369","severity":1,"message":"370","line":68,"column":3,"nodeType":"384","messageId":"372","endLine":68,"endColumn":50},{"ruleId":"369","severity":1,"message":"370","line":74,"column":3,"nodeType":"384","messageId":"372","endLine":74,"endColumn":61},{"ruleId":"369","severity":1,"message":"370","line":80,"column":3,"nodeType":"384","messageId":"372","endLine":80,"endColumn":44},{"ruleId":"369","severity":1,"message":"370","line":89,"column":3,"nodeType":"384","messageId":"372","endLine":89,"endColumn":49},{"ruleId":"369","severity":1,"message":"370","line":14,"column":3,"nodeType":"384","messageId":"372","endLine":14,"endColumn":35},{"ruleId":"369","severity":1,"message":"370","line":48,"column":3,"nodeType":"384","messageId":"372","endLine":48,"endColumn":58},{"ruleId":"369","severity":1,"message":"370","line":110,"column":3,"nodeType":"384","messageId":"372","endLine":110,"endColumn":38},{"ruleId":"369","severity":1,"message":"370","line":127,"column":3,"nodeType":"384","messageId":"372","endLine":127,"endColumn":35},{"ruleId":"369","severity":1,"message":"370","line":141,"column":3,"nodeType":"384","messageId":"372","endLine":141,"endColumn":38},{"ruleId":"369","severity":1,"message":"370","line":7,"column":19,"nodeType":"371","messageId":"372","endLine":13,"endColumn":5},{"ruleId":"369","severity":1,"message":"370","line":37,"column":22,"nodeType":"371","messageId":"372","endLine":37,"endColumn":43},{"ruleId":"369","severity":1,"message":"370","line":42,"column":25,"nodeType":"371","messageId":"372","endLine":42,"endColumn":48},"@typescript-eslint/no-unused-vars","'useEffect' is defined but never used.","Identifier","unusedVar","'Vector3' is defined but never used.","'HighlightHover' is defined but never used.","'chunkSize' is defined but never used.","'PlaceObject' is defined but never used.","'ChunksData' is defined but never used.","'VoxelInfo' is defined but never used.","'Layers' is defined but never used.","'placeRock' is defined but never used.","'placeTree' is defined but never used.","'Structure' is defined but never used.","@typescript-eslint/explicit-module-boundary-types","Missing return type on function.","ArrowFunctionExpression","missingReturnType","@typescript-eslint/no-non-null-assertion","Forbidden non-null assertion.","TSNonNullExpression","noNonNull","FunctionDeclaration","'size' is assigned a value but never used.","'useState' is defined but never used.","'rotationValue' is assigned a value but never used.","'Noise' is defined but never used.","'seedrandom' is defined but never used.","'_' is defined but never used.","FunctionExpression","'Color' is defined but never used.","'useChunkStore' is defined but never used.","'useGroundStore' is defined but never used.","'Curve' is defined but never used.","'id' is defined but never used.","'origin' is defined but never used.","'useMemo' is defined but never used.",["394"],"'relY' is assigned a value but never used.",{"messageId":"395","fix":"396","desc":"397"},"suggestOptionalChain",{"range":"398","text":"399"},"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator.",[572,573],"?"]